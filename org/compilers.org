#+SETUPFILE: ../theme-rose.setup
#+DATE: <2020-10-29 Thu 12:06>
#+TITLE: Compilers

#+BEGIN_EXPORT html
<essay>
谁能想到，有一天，百度百科上的资料，竟然也有料……
</essay>
#+END_EXPORT

** 编译过程概述[fn:1]

源程序是给人看的，本质上就是文本文件，可以用文本编辑程序打开、编辑，但计算机无法直接执行源程序，需要通过一个专门的程序将源程序编译为计算机可执行程序，这个专门的程序就是 _编译器_ 。

编译过程主要分为词法分析、语法分析、中间代码生成、目标代码生成等。

*** 词法分析

我们眼中看到的源代码，如下：

#+BEGIN_SRC c -n
  int fun(int a, int b);
  int m=10;
  int main()
  {
    int i=4;
    int j=5;
    m = fun(i,j);
    return 0;
  }
  int fun(int a, int b)
  {
    int c=0;
    c=a+b;
    return c;
  }
#+END_SRC

而它在计算机中存储的形式（十六进制形式）如下：

#+BEGIN_EXPORT html
<img
src="/images/os/compiler-1.jpg"
width="460"
height=""
style=""
title=""
/>
#+END_EXPORT

很显然，这里是看不出关键字、运算符、标识符，甚至看不出哪几个字符属于同一个符号。

与人相比，现在计算机的智能还是相当低的，无法像人那样同时看多个字符，只能依据一个非常机械的“电子版”词法，一个字符一个字符地识别。

#+BEGIN_EXPORT html
<note>
“电子版”词法是将状态转换图的思路融汇在词法分析器的代码中得以体现的。
</note>
#+END_EXPORT

词法分析器从源程序的字符串中识别出一个个符号（token），并按顺序保存。词法分析的结果如下：

#+BEGIN_EXPORT html
<img
src="/images/os/compiler-2.jpg"
width="460"
height=""
style=""
title=""
/>
#+END_EXPORT

在词法分析阶段能够识别出一些符号的含义，它们包括关键字、数字、字符串、分隔符，这些符号的含义不需要其他符号的辅助就能确定本身的含义。比如， =int= 一定代表整数类型，它不可能是一个变量名称，也不可能是一个运算符。

而另外一些符号则需要通过前后的其他符号才能确定出准确的含义。比如 =m= ，在词法阶段仅能判断这是一个标识符，但是如果不对所在的句做分析，就无法得知这个标识符代表一个变量还是一个函数。更多详细的信息需要对符号所在的句型做分析才能获得，这部分的工作由语法分析来完成。

*** 语法分析

如果说词法分析的作用是从连续的字符中识别出标识符、关键字、数字、运算符并存储为符号（token）流，语法分析的作用就是从词法分析识别出的符号流中识别出符合 C 语言规范的语句。

#+BEGIN_EXPORT html
<essay>
语法分析的作用就是从符号（token）流中识别出符合相应编程语言（C、Java...）规范的语句。
</essay>
#+END_EXPORT

因为计算机无法像人那样同时看多个标识符、关键字、数字、运算符，无法像人那样一眼看出这是一个函数声明，那是一个 =if= 语句，只能非常笨拙地一个符号一个符号去识别。

与词法分析器有些类似，语法分析器也是依据用计算机表示的语法，一个符号一个符号地识别出符合 C 语言语法的语句。

语法的计算机表示就是 _产生式_ ，在语法分析器中把通过 _产生式_ 产生的 C 语言语法映射成一套模板，并把这套模板融汇在语法分析器的程序中。语法分析器的作用就是将词法分析器识别出的符号（token）一个一个地与这套模板进行匹配，匹配上这套模板中的某个语法，就可以识别出一名完整的语句，并确定这条语句的语法。

#+BEGIN_EXPORT html
<essay>
Hmm... 有点抽象，所以需要具体的实践。
</essay>
#+END_EXPORT

我们以案例中 =int fun(int a, int b);= 这条函数语句为例描述这个过程，它与语句模板的匹配情况如下：

#+BEGIN_EXPORT html
<img
src="/images/os/compiler-3.png"
width="540"
height=""
style=""
title=""
/>
#+END_EXPORT
=Figure：fun 函数声明语句与模板匹配的结果=

这段 token 流最终与函数声明模板相匹配，在匹配成功后，计算机就认为此语句为函数声明语句，并以 _语法树_ 的形式在内存中记录下来，如下：

#+BEGIN_EXPORT html
<img
src="/images/os/compiler-4.png"
width="660"
height=""
style=""
title=""
/>
#+END_EXPORT
=Figure：fun 函数声明语句生成的语法树=

以树型结构来记录分析出的语句是一个非常巧妙、深谋远虑、通盘考虑的选择。一方面，树型结构能够“记住”源程序全部的“意思”，另一方面，树型结构更容易对应到运行时结构。

*** 从语法树到中间代码再到目标代码

至此，语法树已经承载了源程序的全部信息，后续的转换工作就和源程序没关系了。

#+BEGIN_QUOTE
如果希望一步到位，从语法树转换为目标代码，理论上和实际上都是可行的。但计算机存在多种 CPU 硬件平台，考虑到程序在不同 CPU 之间的可移植性，先转换成一个通用的、抽象的“CPU 指令”，这就是中间代码最初的设计思想。然后根据具体选定的 CPU ，将中间代码落实到具体 CPU 的目标代码。
#+END_QUOTE

语法树是个二维结构，中间代码是准一维结构，语法树到中间代码的转换过程，本质上是将二维结构转换为准一维结构的过程。中间代码特别是 RTL 已经可以和运行时结构一一对应了，如下图：

#+BEGIN_EXPORT html
<img
src="/images/os/compiler-5.jpg"
width="100%"
height=""
style=""
title=""
/>
#+END_EXPORT
=Figure：中间代码与目标代码对应的情景示意=

运行时结构也是一样维的，上图左侧部分的转换结果将更贴近运行时结构。

选定具体的 CPU、操作系统后，中间代码就可以转换为目标代码 -- 汇编代码（这里我们配置的是 AT&T 汇编），这时操作系统是影响还比较小。然后由汇编器依照选定操作系统的目标文件格式，将 =.s= 文件转换为具体的目标文件，对于 Linux 而言是 =.o= 文件，对于 Windows 而言是 =.obj= 文件，目标文件中已经是选定的 CPU 的机器指令了。

最后，链接器把一个或多个目标文件（库文件本质上也是目标文件）链接成符合操作系统指定格式的可执行文件。

通过操作系统，可执行程序就可以被载入内存执行，形成运行时结构。

后续内容将详细讲解编译的主要过程：词法分析、语法分析、中间代码到目标代码，然后是汇编与链接，最后讲解预处理。

** 编译原理三大经典

| 代号             | 书名                                             | 译名                          | 作者                                       |
|------------------+--------------------------------------------------+-------------------------------+--------------------------------------------|
| 龙书 Dragon book | 《Compilers: Principles, Techniques, and Tools》 | 《编译原理技术和工具》        | Alfred V.Aho, Ravi Sethi, Jeffrey D.Ullman |
| 虎书 Tiger book  | 《Modern Compiler Implementation in C》          | 《现代编译原理 - C 语言描述》 | Andrew W.Appel, Jens Palsberg              |
| 鲸书 Whale book  | 《Advanced Compiler Design and Implementation》  | 《高级编译器设计与实现 》     | Steven S.Muchnick                          |

* Footnotes

[fn:1] https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/4194?fr=aladdin#6
