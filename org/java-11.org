#+SETUPFILE: ../theme-rose.setup
#+DATE: <2020-09-29 Tue 19:05>
#+TITLE: 集合、泛型和枚举

Java 的集合就像一个容器，用来存储 Java 类的对象。

** 集合

在编程时，可以使用数组来保存多个对象，但数组长度一旦指定就不可变化，而且数组无法保存具有映射关系的数据。

为了保存数量不确定的数据，以及保存具有映射关系的数据（也被称为关联数组），Java 提供了集合类。

集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。Java 所有的集合类都位于 =java.util= 包下，提供了一个表示和操作对象集合的统一构架，包含了大量集合接口，以及这些接口的实现类和操作的算法。

集合类和数组不一样，数组元素既可以是基本类型的值，也可以是对象（实际上保存的是对象的引用变量），而集合里只能保存对象。

Java 集合类型分为 =Collection= 和 =Map= ，它们是 Java 集合的根接口，这两个接口又包含了一些子接口或实现类。

#+CAPTION: Collection 接口基本结构
[[../images/java/java-8.png]]

#+BEGIN_EXPORT html
<img
src="/images/java/java-9.png"
width="500"
height=""
style=""
title=""
/>
#+END_EXPORT
=Figure 2: Map 接口基本结构=

*注：上图中，黄色块为集合的接口，蓝色为集合的实现类。

#+CAPTION: Java 集合接口的作用
| 接口名称     | 作用                                                                                                                                                                                           |
|--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =Iterator=   | 集合的输出接口，主要用于遍历输出（即迭代访问） =Collection= 集合中的元素， =Iterator= 对象被称之为迭代器。迭代器接口是集合接口的父接口，实现类实现 =Collection= 时就必须实现 =Iterator= 接口。 |
| =Collection= | 是 =List、Set= 和 =Queue= 的父接口，是存放一组单值的最大接口。所谓的单值是指集合中的每个元素都是一个对象，一般很少使用此接口直接操作。                                                         |
| =Queue=      | ~Queue~ 是 Java 提供的队列实现，有点类似于 =List= 。                                                                                                                                           |
| =Dueue=      | 是 =Queue= 的一个子接口，为双向队列。                                                                                                                                                          |
| =List=       | 是最常用的接口。是有序集合，允许有相同的元素。使用 =List= 能够精确地控制每个元素插入的位置，用户能够使用索引来访问 =List= 中的元素，与数组类似。                                               |
| =Set=        | 不能包含重复的元素。                                                                                                                                                                           |
| =Map=        | 是存放一对值的最大接口，即接口中的每个元素都是一对，以 =key → value= 的形式保存。                                                                                                              |

对于 =Set、List、Queue= 和 =Map= 这 4 种集合，Java 最常用的实现类分别是 =HashSet、TreeSet、ArrayList、ArrayDueue、LinkedList= 和 =HashMap、TreeMap= 等。

#+CAPTION: Java 集合实现类的作用
| 类名称       | 作用                                                                                                                                                                                                   |
|--------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| =HashSet=    | 为优化查询速度而设计的 =Set= 。它是基于 =HashMap= 实现的， =HashSet= 底层使用 =HashMap= 来保存所有元素，实现比较简单。                                                                                 |
| =TreeSet=    | 实现了 =Set= 接口，是一个有序的 =Set= ，这样就能从 =Set= 里面提取一个有序序列。                                                                                                                        |
| =ArrayList=  | 一个用数组实现的 =List= ，能进行快速的随机访问，效率高而且实现了可变大小的数组。                                                                                                                       |
| =ArrayDueue= | 是一个基于数组实现的双端队列，按“先进先出”的方式操作集合元素。                                                                                                                                         |
| =LinkedList= | 对顺序访问进行了优化，但随机访问的速度相对较慢。此外它还有 =addFirst()、addLast()、getFirst()、getLast()、removeFirst()= 和 =removeLast()= 等方法，能把它当成栈（ =Stack= ） 或队列（ =Queue= ）来用。 |
| =HashMap=    | 按哈希算法来存取键对象。                                                                                                                                                                               |
| =TreeMap=    | 可以对键对象进行排序。                                                                                                                                                                                 |

** Colletion 接口

=Collection= 接口是 =List、Set= 和 =Queue= 接口的父接口，通常情况下不被直接使用。 =Collection= 接口定义了一些通用的方法，通过这些方法可以实现对集合的基本操作，它们也可用于操作 =Set、List、Queue= 。

#+BEGIN_EXPORT html
<essay>
List、Set、Queue 继承自 Collection 接口，自然已经实现了 Collection 接口中的方法。
</essay>
#+END_EXPORT

#+CAPTION: Collection 接口的常用方法
| 方法名称                            | 说明                                                                                                                                                 |
|-------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------|
| =boolean add(E e)=                  | 向集合中添加一个元素，如果集合对象被添加操作改变了，则返回 =true= 。 =E= 是元素的数据类型。                                                          |
| =boolean addAll(Collection c)=      | 向集合中添加集合 =c= 中的所有元素，如果集合对象被添加操作改变了，则返回 =true= 。                                                                    |
| =void clear()=                      | 清除集合中的所有元素，将集合长度变为 =0= 。                                                                                                          |
| =boolean contains(Object o)=        | 判断集合中是否存在指定元素                                                                                                                           |
| =boolean containsAll(Collection c)= | 判断集合中是否包含集合 c 中的所有元素                                                                                                                |
| =boolean isEmpty()=                 | 判断集合是否为空                                                                                                                                     |
| =Iterator<E> iterator()=            | 返回一个 =Iterator= 对象，用于遍历集合中的元素                                                                                                       |
| =boolean remove(Object o)=          | 从集合中删除一个指定元素，当集合中包含了一个或多个元素 =o= 时，该方法 *只删除第一个* 符合条件的元素，该方法将返回 =true= 。                          |
| =boolean removeAll(Collection c)=   | 从集合中删除所有在集合 =c= 中出现的元素（相当于把调用该方法的集合减去集合 =c= ）。如果该操作改变了调用该方法的集合，则该方法返回 =true= 。           |
| =boolean retainAll(Collection c)=   | 从集合中删除集合 =c= 里不包含的元素（相当于把调用该方法的集合变成该集合和集合 =c= 的交集），如果该操作改变了调用该方法的集合，则该方法返回 =true= 。 |
| =int size()=                        | 返回集合中元素的个数                                                                                                                                 |
| =Object[] toArray()=                | 把集合转换为一个数组，所有的集合元素变成对应的数组元素。                                                                                             |

*注： =retainAll()= 方法的作用与 =removeAll()= 方法相反，它保留两个集合中相同的元素，其他全部删除。

集合类像容器，现实生活中容器的功能，就是添加对象、删除对象、清空容器和判断容器是否为空等，集合类为这些功能提供了对应的方法。

#+BEGIN_EXPORT html
<essay>
看，其实只要联系现实，记忆就突然变得简单了，这就是用以为学了。
</essay>
#+END_EXPORT

#+BEGIN_QUOTE
在传统模式下，把一个对象“丢进”集合中后，集合会忘记这个对象的类型。也就是说，系统把所有的集合元素都当成 Object 类型。从 Java 5 以后，可以使用泛型来限制集合里元素的类型，并让集合记住所有集合元素的类型。
#+END_QUOTE

** List 集合

=List= 是一个有序、可重复的集合，集合中每个元素都有其对应的顺序索引，默认按元素的添加顺序设置元素的索引，可以通过索引来访问指定位置的元素。

=List= 实现了 =Collection= 接口，它主要有两个常用的实现类： =ArrayList= 类和 =LinkedList= 类。

*** ArrayList 类

=ArrayList= 类实现了可变数组的大小，存储在内的数据称为元素。它还提供了快速基于索引访问元素的方式，对 *尾部成员* 的增加和删除支持较好。

*注：向 =ArrayList= 中（除尾部成员）插入与删除元素的速度相对较慢。

=ArrayList= 类的常用构造方法有如下两种重载形式：
- =ArrayList()= ：构造一个初始容量为 10 的空列表；
- =ArrayList(Collection<?extends E> c)= ：构造一个包含指定 =Collection= 元素的列表，这些元素是按照 =Collection= 的迭代器返回它们的顺序排列的。

=ArrayList= 类除了包含 =Collection= 接口的所有方法之外，还包括 =List= 接口中提供的如下表所示的方法。

#+CAPTION: ArrayList 类的常用方法
| 方法名称                                      | 说明                                                                                                |
|-----------------------------------------------+-----------------------------------------------------------------------------------------------------|
| =E get(int index)=                            | 获取此集合中指定索引位置的元素， =E= 为集合中元素的数据类型                                         |
| =E set(int index, E element)=                 | 将此集合中指定索引位置的元素修改为 =element= 参数指定的对象。此方法返回此集合中指定索引位置的原元素 |
| =int index(Object o)=                         | 返回此集合中第一次出现指定元素的索引，如果此集合不包含该元素，则返回 =-1=                           |
| =int lastIndexOf(Object o)=                   | 返回此集合中最后一次出现指定元素的索引，如果此集合不包含该元素，则返回 =-1=                         |
| =List<E> subList(int fromIndex, int toIndex)= | 返回一个新的集合，新集合中包含 =fromIndex= 和 =toIndex= 索引之间的所有元素（左闭右开）              |

*** LinkedList 类

=LinkedList= 类采用链表结构保存对象，这种结构的优点是便于向集合中插入或者删除元素。

*注：需要频繁向集合中插入和删除元素时，使用 =LinkedList= 类比 =ArrayList= 类效果高，但是 =LinkedList= 类随机访问元素的速度则相对较慢。

=LinkedList= 类除了包含 =Collection= 接口中的所有方法之外，还特别提供了下表所示的方法：

#+CAPTION: LinkList 类中的方法
| 方法名称             | 说明                         |
|----------------------+------------------------------|
| =void addFirst(E e)= | 将指定元素添加到此集合的开头 |
| =void addLast(E e)=  | 将指定元素添加到此集合的末尾 |
| =E getFirst()=       | 返回此集合的第一个元素       |
| =E getLast()=        | 返回此集合的最后一个元素     |
| =E removeFirst()=    | 删除此集合中的第一个元素     |
| =E removeLast()=     | 删除此集合中的最后一个元素   |

=LinkedList<String>= 中的 =<String>= 是 Java 中的泛型， *用于指定集合中元素的数据类型* ，例如这里指定元素类型为 =String= ，则该集合中不能添加非 =String= 类型的元素。

*** ArrayList VS LinkedList

=ArrayList= 与 =LinkedList= 都是 =List= 接口的实现类，因此都实现了 =List= 的所有未实现的方法，只是实现的方式有所不同。

*注： =LinkedList= 类同时实现了 =Dueue= 接口和 =List= 接口。

=ArrayList= 是基于动态数组数据结构的实现，访问速度优于 =LinkedList= ； =LinkedList= 是基于链表数据结构的实现，占用的内存空间较大，但在批量插入或删除数据时优于 =ArrayList= 。

#+BEGIN_QUOTE
不同的结构对应于不同的算法，有的考虑节省占用空间，有的考虑提高运行效率，对于程序员而言，它们就像是“熊掌”和“鱼肉”，不可兼得。高运行速度往往是以牺牲空间为代价的，而节省占用空间往往是以牺牲运行速度为代价的。
#+END_QUOTE

** Set 集合

=Set= 集合类似于一个罐子，程序可以把多个对象“丢进” =Set= 集合，而 =Set= 集合通常不能记住元素的添加顺序。也就是说， =Set= 集合中的对象不按特定的方式排序，只是简单地把对象加入集合，它不能包含重复的对象，并且最多只允许包含一个 =null= 元素。

=Set= 实现了 =Collection= 接口，它主要有两个常用的实现类： =HashSet= 类和 =TreeSet= 类。

*** HashSet 类

=HashSet= 是 =Set= 接口的典型实现，大多数时候使用 =Set= 集合时就是使用这个实现类。 =HashSet= 是按照 =Hash= 算法来存储集合中的元素，因此具有很好的存取和查找性能。

=HashSet= 具有以下特点：
- 不能保证元素的排列顺序，顺序可能与添加顺序不同，顺序也有可能发生变化；
- =HashSet= 不是同步的，如果多个线程同时访问或修改一个 =HashSet= ，则必须通过代码来保证其同步；
- 集合元素值可以是 =null= 。

当向 =HashSet= 集合中存入一个元素时， =HashSet= 会调用该对象的 =hasCode()= 方法来得到该对象的 =hasCode= 值，然后根据该 =hasCode= 值决定该对象在 =HashSet= 中的存储位置。

如果有两个元素通过 =equals()= 方法比较返回的结果为 =true= ，但它们的 =hasCode= 不相等， =HashSet= 将会把它们存储在不同的位置，依然可以添加成功。

也就是说，两个对象的 =hasCode= 值相等且通过 =equals()= 方法比较返回结果为 =true= ，则 =HashSet= 集合认为两个元素相等。

在 =HashSet= 类中实现了 =Collection= 接口中的所有方法， =HashSet= 类的常用构造方法重载形式如下：
- =HashSet()= ：构造一个新的空的 =Set= 集合；
- =HashSet(Collection<? extends E> c)= ：构造一个包含指定 =Collection= 集合元素的新 =Set= 集合。其中， =< >= 中的 =extends= 表示 =HashSet= 的父类，即指明该 =Set= 集合中存放的集合元素类型。 =c= 表示其中的元素将被存放在此 =Set= 集合中。

下面的代码演示了创建两种不同形式的 =HashSet= 对象：
#+BEGIN_SRC java -n
  HashSet hs = new HashSet();                  // 调用无参的构造函数创建 HashSet 对象
  HashSet<String> hss = new HashSet<String>(); // 创建泛型的 HashSet 集合对象
#+END_SRC

*** TreeSet 类

=TreeSet= 类同时实现了 =Set= 接口和 =SortedSet= 接口。 =SortedSet= 接口是 =Set= 接口的子接口，可以实现对集合进行自然排序，因此使用 =TreeSet= 类实现的 =Set= 接口默认情况下是自然排序（升序排序）的。

=TreeSet= 只能对实现了 =Comparable= 接口的类对象进行排序，因为 =Comparable= 接口有一个 =compareTo(Object o)= 方法用于比较两个对象的大小。

例如 =a.compareTo(b)= ，如果 =a= 和 =b= 相等，则该方法返回 =0= ；如果 =a= 大于 =b= ，则该方法返回大于 =0= 的值；如果 =a= 小于 =b= ，则该方法返回小于 =0= 的值。

下表列举了 JDK 类库中实现 =Comparable= 接口的类，以及这些类对象的比较方式：

#+CAPTION: 实现 Comparable 接口类对象的比较方式
| 类                                                                                  | 比较方式                                |
|-------------------------------------------------------------------------------------+-----------------------------------------|
| 包装类（ =BigDecimal、BigInteger、Byte、Double、Float、Integer、Long= 及 =Short= ） | 按数字大小比较                          |
| =Character=                                                                         | 按字符的 Unicode 值的数字大小比较       |
| =String=                                                                            | 按字符中字符的 Unicode 值的数字大小比较 |

=TreeSet= 类除了实现 =Collection= 接口的所有方法之外，还提供了如下表所示的方法：

#+CAPTION: TreeSet 类的常用方法
| 方法名称                                          | 说明                                                                                                 |
|---------------------------------------------------+------------------------------------------------------------------------------------------------------|
| =E first()=                                       | 返回此集合中的第一个元素。其中， =E= 表示集合中元素的数据类型。                                      |
| =E last()=                                        | 返回此集合中的最后一个元素                                                                           |
| =E poolFirst()=                                   | 获取并移除此集合中的第一个元素                                                                       |
| =E poolLast()=                                    | 获取并移除此集合中的最后一个元素                                                                     |
| =SortedSet<E> subSet(E fromElement, E toElement)= | 返回一个新的集合，新集合包含原集合中 =fromElement= 对象与 =toElement= 对象之间的所有对象，左闭右开。 |
| =SortedSet<E> headSet<E toElement>=               | 返回一个新的集合，新集合包含原集合中 =toElement= 对象之前的所有对象，不包含 =toElement= 对象。       |
| =SortedSet<E> tailSet<E fromElement>=             | 返回一个新的集合，新集合包含原集合中 =fromElement= 对象之后的所有对象，包含 =fromElement= 对象。     |

*注：表面上看起来这些方法很多，其实很简单。因为 =TreeSet= 中的元素是 _有序的_ ，所以增加了访问第一个、前一个、后一个、最后一个元素的方法，并提供了 3 个从 =TreeSet= 中截取子 =TreeSet= 的方法。

在使用自然排序时只能向 =TreeSet= 集合中添加相同数据类型的对象，否则会抛出 =ClassCastException= 异常。

** Map 集合

=Map= 是一种键值对（ =key-value= ）集合，用于保存具有映射关系的数据。

=Map= 集合里保存着两组值，一组值用于保存 =Key= ，另一组值用于保存 =value= ， *=Key= 和 =value= 都可以是任何引用类型的数据* 。其中， =key= 不允许重复， =value= 可以重复。

=Map= 中的 =key= 和 =value= 之间存在单向一对一关系，即通过指定的 =key= ，总能找到唯一的、确定的 =value= 。

=Map= 接口主要有两个实现类： =HashMap= 类和 =TreeMap= 类。其中， =HashMap= 类按哈希算法来存取键对象，而 =TreeMap= 类可以对键对象进行排序。

#+CAPTION: Map 接口的常用方法
| 方法名称                                   | 说明                                                                                                                                                |
|--------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------|
| =void clear()=                             | 删除该 =Map= 对象中的所有 =key-value= 对。                                                                                                          |
| =boolean containsKey(Object key)=          | 查询 =Map= 中是否包含指定的 =key= ，如果包含则返回 =true= 。                                                                                        |
| =boolean containsValue(Object value)=      | 查询 =Map= 中是否包含一个或多个的 =value= ，如果包含则返回 =true= 。                                                                                |
| =V get(Object key)=                        | 返回 =Map= 集合中指定键对象所对应的值， =V= 表示值的数据类型。                                                                                      |
| =V put(K key, V value)=                    | 向 =Map= 集合中添加键-值对，如果当前 =Map= 中已有一个与该 =key= 相等的 =key-value= 对，则新的 =key-value= 对会覆盖原来的 =key-value= 对。           |
| =void putAll(Map m)=                       | 将指定 =Map= 中的 =key-value= 对复制到本 =Map= 中。                                                                                                 |
| =V remove(Object key)=                     | 从 =Map= 集合中删除 =key= 对应的键-值对，返回 =key= 对应的 =value= ，如果该 =key= 不存在，则返回 =null= 。                                          |
| =boolean remove(Object key, Object value)= | （Java 8 新增）删除指定 =key、value= 所对应的 =key-value= 对。如果从该 =Map= 中成功地删除该 =key-value= 对，该方法返回 =true= ，否则返回 =false= 。 |
| =Set entrySet()=                           | 返回 =Map= 集合中所有键-值对的 =Set= 集合，此 =Set= 集合中元素的数据类型为 =Map.Entry=                                                              |
| =Set keySet()=                             | 返回 =Map= 集合中所有键对象的 =Set= 集合                                                                                                            |
| =boolean isEmpty()=                        | 查询该 =Map= 是否为空（即不包含任何 =key-value= 对），如果为空则返回 =true= 。                                                                      |
| =int size()=                               | 返回该 =Map= 里 =key-value= 对的个数                                                                                                                |
| =Collection values()=                      | 返回该 =Map= 里所有 =value= 组成的 =Collection=                                                                                                     |

=Map= 集合最典型的用法就是成对地添加、删除 =key-value= 对，接下来即可判断该 =Map= 中是否包含指定 =key= ，也可以通过 =Map= 提供的 =keySet()= 方法获取所有 =key= 组成的集合，进而遍历 =Map= 中所有的 =key-value= 对。

**注： =TreeMap= 类的使用方法与 =HashMap= 类相同，唯一不同的是 =TreeMap= 类可以对键对象进行排序。*

_#. 遍历 Map 集合_

=Map= 集合的遍历与 =List= 和 =Set= 集合不同。 =Map= 有两组值，因此遍历时可以只遍历值的集合，也可以只遍历键的集合，也可以同时遍历。 =Map= 以及实现 =Map= 的接口类（如 =HashMap、TreeMap、LinkedHashMap、Hashtable= 等）都可以用以下几种方式遍历。

（1）在 =for= 循环中使用 =entries= 实现 =Map= 的遍历（最常见和最常用的）。

#+BEGIN_SRC java -n
  public static void main(String[] args) {
      Map<String, String> map = new HashMap<String, String>();
      map.put("Java Tutor", "tutor/java/");
      map.put("C++ Tutor", "tutor/cpp/");

      for (Map.Entry<String, String> entry : map.entrySet()) {
          String mapKey = entry.getKey();
          String mapValue = entry.getValue();
          System.out.println(mapKey + ": " + mapValue);
      }
  }
#+END_SRC

（2）使用 =for-each= 循环遍历 =key= 或者 =values= ，一般适用于只需要 =Map= 中的 =key= 或者 =value= 时使用，性能上 =entrySet= 较好。

#+BEGIN_SRC java -n
  public static void main(String[] args) {
      Map<String, String> map = new HashMap<String, String>();
      map.put("Java Tutor", "tutor/java/");
      map.put("C++ Tutor", "tutor/cpp/");

      for (String key : map.keySet()) {
          System.out.println(key);
      }

      for (String value : map.values()) {
          System.out.println(value);
      }
  }
#+END_SRC

（3）使用迭代器（ =Iterator= ）遍历

#+BEGIN_SRC java -n
  public static void main(String[] args) {
      Map<String, String> map = new HashMap<String, String>();
      map.put("Java Tutor", "tutor/java/");
      map.put("C++ Tutor", "tutor/cpp/");

      Iterator<Entry<String, String>> entries = map.entrySet().iterator();
      while (entries.hasNext()) {
          Entry<String, String> entry = entries.next();
          String key = entry.getKey();
          String value = entry.getValue();
          System.out.println(key + ": " + value);
      }
  }
#+END_SRC

（4）通过键值遍历，这种方式的效率比较低，因为本身从键值是耗时的操作。

#+BEGIN_SRC java -n
  for (String key : map.keySet()) {
      String value = map.get(key);
      System.out.println(key + ": " + value);
  }
#+END_SRC

** TODO Collections 类

** 泛型

前面我们提到 Java 集合有个缺点，就是把一个对象“丢进”集合里之后，集合就会“忘记”这个对象的数据类型，当再次取出对象时，该对象的编译类型就变成了 =Object= 类型（其运行时类型没变）。

Java 集合之所以被设计成这样，是因为集合的设计者不知道我们用集合来保存什么类型的对象，所以他们把集合设计成能保存任何类型的对象，只需求具有很好的通用性。但这样做带来如下两个问题：

（1）集合对元素类型没有任何限制，这可能引发一些问题，例如，想创建一个只能保存 =Dog= 对象的集合，但程序也可以轻易地将 =Cat= 对象“丢”进去，所以可能引发异常。

（2）由于把对象“丢进”集合时，集合丢失了对象的状态信息，集合只知道它盛装的是 =Object= ，因此取出集合元素后通常还需要进行强制类型转换。这种强制类型转换既增加了编程的复杂度，也可能引发 =ClassCastException= 异常。

为了解决上述问题，从 Java 1.5 开始提供了泛型。

*泛型可以在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高了代码的重用率。*

*** 泛型集合

*泛型，本质上是提供类型的“类型参数”，也就是参数化类型。*

我们可以为类、接口或方法指定一个类型参数，通过这个参数限制操作的数据类型，从而保证类型转换的绝对安全。

来看个例子，下面将结合泛型与集合编写一个案例实现图书信息输出：

（1）首先创建一个表示图书的实体类 =Book= ，其中包括图书信息的编号、名称和价格。代码如下：

#+BEGIN_SRC java -n
  public class Book {
      private int Id;
      private String Name;
      private int Price;

      public Book(int id, String name, int price) {
          this.Id = id;
          this.Name = name;
          this.Price = price;
      }

      public String toString() {
          return this.Id + ", " + this.Name + ", " + this.Price;
      }
  }
#+END_SRC

（2）使用 Book 作为类型创建 Map 和 List 两个泛型集合，然后向集合中添加图书元素，最后输出集合中的内容，代码如下：

#+BEGIN_SRC java -n
  public class Test {
      public static void main(String[] args) {
          Book book1 = new Book(1, "BOOK1", 8);
          Book book2 = new Book(2, "BOOK2", 12);
          Book book3 = new Book(3, "BOOK3", 22);

          // 定义泛型 Map 集合
          Map<Integer, Book> books = new HashMap<Integer, Book>();
          books.put(1001, book1);
          books.put(1002, book2);
          books.put(1003, book3);
          System.out.println("泛型 Map 存储的图书信息如下：");
          for (Integer id : books.keySet()) {
              System.out.println(id + "--");
              System.out.println(books.get(id)); // 不需要类型转换
          }

          // 定义泛型的 List 集合
          List<Book> bookList = new ArrayList<Book>();
          bookList.add(book1);
          bookList.add(book2);
          bookList.add(book3);
          System.out.println("泛型 List 存储的图书信息如下：");
          for (int i = 0; i < bookList.size(); i++) {
              System.out.println(bookList.get(i)); // 不需要类型转换
          }
      }
  }
#+END_SRC
