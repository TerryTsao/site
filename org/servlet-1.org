#+SETUPFILE: ../theme-rose.setup
#+DATE: <2020-10-06 Tue 14:08>
#+TITLE: Servlet 是什么

** Web 开发[fn:1]

JavaEE 是什么？它并不是一个软件产品，更多的是一种软件架构和设计思想，它是在 JavaSE 的基础上，开发的一系列基于服务的组件、API 标准和通用架构。

JavaEE 最核心的组件就是基于 Servlet 标准的 Web 服务器，开发者编写的应用程序是基于 Servlet API 并运行在 Web 服务器内部的：

#+BEGIN_EXPORT html
<img
src="/images/java/java-29.png"
width=""
height=""
style="float: right; margin-left: 16px;"
title=""
/>
#+END_EXPORT

此外，JavaEE 还有一系列的技术标准，目前最流行的基于 Spring 的轻量级 JavaEE 开发架构，使用最广泛的是 Servlet 和 JMS（Java Message Service，消息服务），以及一系列开源组件。

我们访问网站，使用 App 时，都是基于 Web 这种 Browser/Server 模式，简称 BS 架构，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取 Web 页面，并把页面展示给用户即可。

在 Web 应用中，浏览器请求一个 URL ，服务器就把生成的 HTML 网页发送给浏览器，而浏览器和服务器之间的传输协议是 HTTP ，HTTP 协议是一个基于 TCP 协议上的请求-响应协议。

所为 _HTTP 编程_ 是以客户端的身份去请求服务器资源，现在，我们需要以服务器的身份响应客户端请求，编写服务器程序来处理客户端请求通常就称之为 _Web 开发_ 。

*那么，如何编写一个 HTTP Server 呢？*

一个 HTTP Server 本质上是一个 TCP 服务器，我们先用 TCP 编程的多线程实现一个服务器框架：

#+BEGIN_SRC java -n
  public class Server {
      public static void main(String[] args) throws IOException {
          ServerSocket ss = new ServerSocket(8080); // 监听指定端口
          System.out.println("Server is running...");
          for (;;) {
              Socket sock = ss.accept();
              System.out.println("Connected from " + sock.getRemoteSocketAddress());
              Thread t = new Handler(sock);
              t.start();
          }
      }
  }

  class Handler extends Thread {
      Socket sock;

      public Handler(Socket sock) {
          this.sock = sock;
      }

      public void run() {
          try (InputStream input = this.sock.getInputStream()) {
              try (OutputStream output = this.sock.getOutputStream()) {
                  handle(input, output);
              }
          } catch (Exception e) {
              try {
                  this.sock.close();
              } catch (IOException ioe) {

              }
              System.out.println("Client disconnected.");
          }
      }

      private void handle(InputStream input, OutputStream output) throws IOException {
          var reader = new BufferedReader(new InputStreamReader(input, StrandardCharsets.UTF_8));
          var writer = new BufferedWriter(new OutputStreamWriter(output, StrandardCharsets.UTF_8));
          // TODO: 处理 HTTP 请求
          // ...
      }
  }
#+END_SRC

只需要在 =handle()= 方法中，用 Reader 读取 HTTP 请求，用 Writer 发送 HTTP 响应，即可实现一个最简单的 HTTP 服务器。编写代码如下：

#+BEGIN_SRC java -n
  private void handle(InputStream input, OutputStream output) throws IOException {
      System.out.println("Process new http request...");
      var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));
      var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));

      // 读取 HTTP 请求
      boolean requestOk = false;
      String first = reader.readLine();
      if (first.startsWith("GET / HTTP/1.")) {
          requestOk = true;
      }
      for (;;) {
          String header = reader.readLine();
          if (header.isEmpty()) { // 读取到空行时，HTTP Header 读取完毕
              break;
          }
          System.out.println(header);
      }
      System.out.println(requestOk ? "Response OK" : "Response Error");

      if (!requestOk) {
          // 发送错误响应
          writer.write("HTTP/1.0 404 Not Found\r\n");
          writer.write("Content-Length: 0\r\n");
          writer.write("\r\n");
          writer.flush();
      } else {
          // 发送成功响应
          String data = "<html><body><h1>Hello, world!</h1></body></html>";
          int length = data.getBytes(StandardCharsets.UTF_8).length;
          writer.write("HTTP/1.0 200 OK\r\n");
          writer.write("Connection: close\r\n");
          writer.write("Content-Type: text/html\r\n");
          writer.write("Content-Length: " + length + "\r\n");
          writer.write("\r\n");   // 空行标识 Header 和 Body 的分隔
          writer.write(data);
          writer.flush();
      }
  }
#+END_SRC

这里的核心代码是，先读取 HTTP 请求，这里我们只处理 =GET /= 的请求。当读取到空行时，表示已读到连续两个 =\r\n= ，说明请求结束，可以发送响应。发送响应的时候，首先发送响应代码 =HTTP/1.0 200 OK= 表示一个成功的 =200= 响应，使用 =HTTP/1.0= 协议，然后，依次发送 Header ，发送完 Header 后，再发送一个空行标识 Header 结束，紧接着发送 HTTP Body，在浏览器输入 =http://local.liaoxuefent.com/8080/= 就可以看到响应页面：

#+BEGIN_EXPORT html
<img
src="/images/java/java-30.jpg"
width=""
height=""
style=""
title=""
/>
#+END_EXPORT

HTTP 目前有多个版本， =1.0= 是早期版本，浏览器每次建立 TCP 连接后，只发送一个 HTTP 请求并接收一个 HTTP 响应，然后就关闭 TCP 连接。

由于创建 TCP 连接本身就需要消耗一定的时间，因此，HTTP 1.1 允许浏览器和服务器在同一个 TCP 连接上反复发送、接收多个 HTTP 请求和响应，这样就大大提高了传输效率。

然而，HTTP 协议是一个请求-响应协议，它都是发送一个请求，然后接收一个响应。能不能一次性发送多个请求，然后再接收多个响应呢？

可以的！

HTTP 2.0 可以支持浏览器同时发出多个请求，但每个请求需要唯一标识，服务器可以不按请求的顺序返回多个响应，由浏览器自己把收到的响应和请求对应起来。可见，HTTP 2.0 进一步提高了效率，因为浏览器发出一个请求后，不必等待响应，就可以继续发下一个请求。

HTTP 3.0 为了进一步提高速度，将抛弃 TCP 协议，改为使用无需创建连接的 UDP 协议，目前仍然处于实验阶段。

#+BEGIN_EXPORT html
<essay>
技术的进步是无止境的……
</essay>
#+END_EXPORT

** Servlet 入门

在上一节中，可见，编写 HTTP 服务器其实是非常简单的，只需要先编写基于多线程的 TCP 服务，然后在一个 TCP 连接中读取 HTTP 请求，发送 HTTP 响应即可。

但是，要编写一个完善的 HTTP 服务器，以 HTTP/1.1 为例，需要考虑的包括：
- 识别正确和错误的 HTTP 请求；
- 识别正确和错误的 HTTP 头；
- 利用 TCP 连接；
- 利用线程；
- IO 异常处理；
- ...

BUT 这些基础工作需要耗费大量的时间，并且经过长时间测试才能稳定运行， *太低效了，太难了* 。

幸运的是，在 JavaEE 平台上，处理 TCP 连接，解析 HTTP 协议这些底层工作统统扔给现成的 Web 服务器去做，我们只需要把自己的应用程序跑在 Web 服务器上。

#+BEGIN_EXPORT html
<essay>
交给可靠的机制去运行，省力又省心。
</essay>
#+END_EXPORT

JavaEE 是如何实现这一点的呢？

JavaEE 提供了 Servlet API，我们使用 Servlet API 编写自己的 Servlet 来处理 HTTP 请求，Web 服务器实现 Servlet API 接口，实现底层功能：

#+BEGIN_EXPORT html
<img
src="/images/java/java-31.png"
width=""
height=""
style=""
title=""
/>
#+END_EXPORT

下面我们来实现一个最简单的 Servlet ：

#+BEGIN_SRC java -n
  // WebServlet 注解表示这是一个 Servlet ，并映射到地址 `/` ：
  @WebServlet(urlPatterns = "/")
  public class HelloServlet extends HttpServlet {
      protected void doGet(HttpServletRequest req, HttpServletResponse resp)
          throws ServletException, IOException {
          // 设置响应类型：
          resp.setContentType("text/html");
          // 获取输出流：
          PrintWriter pw = resp.getWriter();
          // 写入响应：
          pw.write("<h1>Hello, world!</h1>");
          // 最后不要忘记 flush 强制输出：
          pw.flush();
      }
  }

#+END_SRC

*一个 Servlet 总是继承自 =HttpServlet= ，然后覆写 =doGet()= 或 =doPost()= 方法* 。

注意到 =doGet()= 方法传入了 =HttpServletRequest= 和 =HttpServletResponse= 两个对象，分别代表 HTTP 请求和响应。

我们使用 Servlet API 时，并不直接与底层 TCP 交互，也不需要解析 HTTP 协议，因为 =HttpServletRequest= 和 =HttpServletResponse= 就已经封装好了请求和响应。以发送响应为例，我们只需要设置正确的响应类型，然后获取 =PrintWriter= ，写入响应即可。

*Servlet API 是什么？*

Servlet API 是一个 jar 包，我们需要通过 Maven 来引入它，才能正常编译。通过 Maven 构建后会得到一个 =.war= 格式的文件，那么， *如何运行这个 =war= 文件呢* ？

普通的 Java 程序是通过启动 JVM ，然后执行 =main()= 方法开始运行。但是 Web 应用程序有所不同，我们无法直接运行 =war= 文件，必须先启动 Web 服务器，再由 Web 服务器加载我们编写的 HelloServlet ，这样就可以让我们编写的 HelloServlet 处理浏览器发送的请求。

*那么，Servlet API是谁提供的呢？*

是由支持 Servlet API 的 Web 服务器提供的！常用的服务器有：
- Tomcat ：由 Apache 开发的开源免费服务器；
- Jetty ：由 Eclipse 开发的开源免费服务器；
- GlassFish ：一个开源的全功能 JavaEE 服务器；
- WebLogic ：Oracle 的商用服务器；
- WebSphere ：IBM 的调用服务器。

无论使用哪个服务器，只要它支持相同版本的 Servlet API ，我们在引版本上开发构建的 =war= 包都可以在上面运行。

我们通常选用最广泛的开源免费的 Tomcat 服务器。

实际上，类似 Tomcat 这样的服务器也是 Java 编写的，启动 Tomcat 服务器实际上是启动 Java 虚拟机，执行 Tomcat 的 =main()= 方法，然后由 Tomcat 负责加载我们的 =.war= 文件，并创建一个我们编写的 HelloServlet 实例，最后以多线程的模式来处理 HTTP 请求。例如，Tomcat 服务器收到的请求路径是 =/= 时，就转发到 HelloServlet 并传入 =HttpServletRequest= 和 =HttpServletResponse= 现个对象。

由上可知，我们编写的 Servlet 并不是直接运行，而是由 Web 服务器加载后创建实例运行，所以，类似于 Tomcat 这样的 Web 服务器也称为 _Servlet 容器_ 。

在 Servlet 容器中运行的 Servlet 具有如下特点：
- 无法在代码中直接通过 new 创建 Servlet 实例，必须由 Servlet 容器自动创建 Servlet 实例；
- Servlet 容器只会给每个 Servlet 类创建唯一实例；
- Servlet 容器会使用多线程执行 =doGet()= 或 =doPost()= 方法。

*注：在 Servlet 中定义的实例变量会被多个线程同时访问，要注意线程安全。正确编写 Servlet ，要清晰理解 Java 的多线程模型，需要同步访问的必须同步。

** Servlet 开发

通常，一个完整的 Web 应用程序的开发流程如下：
1. 编写 Servlet ；
2. 打包为 war 文件；
3. 复制到 Tomcat 的 webapps 目录下；
4. 启动 Tomcat 。

这个过程同样很繁琐（开发者都是“懒虫”啦），而且如果我们想在 IDE 中断点调试，还需要打开 Tomcat 的远程调试端口并且连接上去。

但是，许多初学者经常卡在如何在 IDE 中启动 Tomcat 并加载 webapp，更不要说断点调试了……

Tomcat 实际上也是一个 Java 程序，我们看看 Tomcat 的启动流程：
1. 启动 JVM 并执行 Tomcat 的 =main()= 方法；
2. 加载 =.war= 文件并初始化 Servlet ；
3. 正常服务。

那么，启动 Tomcat 无非就是设置好 classpath 并执行 Tomcat 某个 jar 包的 =main()= 方法，我们完全可以把 Tomcat 的 jar 包全部引入进来，然后自己编写一个 =main()= 方法，先启动 Tomcat ，会后让它加载我们的 webapp 就可以了。

我们新建一个 =web-servlet-embedded= 工程，编写 =pom.xml= 如下：

#+BEGIN_SRC xml -n
  <project xmlns="http://maven.apache.org/POM/4.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
           <modelVersion>4.0.0</modelVersion>

           <groupId>com.itranswarp.leanjava</groupId>
           <artifactId>web-servlet-embedded</artifactId>
           <version>1.0-SNAPSHOT</version>
           <packaging>war</packaging>

           <properties>
             <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
             <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
             <maven.compiler.source>11</maven.compiler.source>
             <maven.compiler.target>11</maven.compiler.target>
             <java.version>11</java.version>
             <tomcat.version>9.0.26</tomcat.version>
           </properties>

           <dependencies>
             <dependency>
               <groupId>org.apache.tomcat.embed</groupId>
               <artifactId>tomcat-embed-core</artifactId>
               <version>${tomcat.version}</version>
               <scope>provided</scope>
             </dependency>
             <dependency>
               <groupId>org.apache.tomcat.embed</groupId>
               <artifactId>tomcat-embed-jasper</artifactId>
               <version>${tomcat.version}</version>
               <scope>provided</scope>
             </dependency>
           </dependencies>
  </project>
#+END_SRC

其中， =<packaging>= 类型仍然为 =war= ，引入依赖 =tomcat-embed-core= 和 =tomcat-embed-jasper= ，引入的 Tomcat 版本为 =<tomcat.version>= 为 =9.0.26= 。

不必引入 Servlet API，因为引入 Tomcat 依赖后自动引入了 Servlet API 。因此，我们可以正常编写 Servlet 如下：

#+BEGIN_SRC java -n
  @WebServlet(urlPatterns = "/")
  public class HelloServlet extends HttpServlet {
      protected void doGet(HttpServletRequest req, HttpServletResponse resp)
          throws ServletException, IOException {
          resp.setContentType("text/html");
          String name = req.getParameter("name");
          if (name == null) {
              name = "world";
          }
          PrintWriter pw = resp.getWriter();
          pw.write("<h1>Hello, " + name + "</h1>");
          pw.flush();
      }
  }
#+END_SRC

然后，我们编写一个 =main()= 方法，启动 Tomcat 服务器：

#+BEGIN_SRC java -n
  public class Main {
      public static void main(String[] args) throws Exception {
          // 启动 Tomcat ：
          Tomcat tomcat = new Tomcat();
          tomcat.setPort(Integer.getInteger("port", 8080));
          tomcat.getConnectory();
          // 创建 webapp ：
          Context ctx = tomcat.addWebApp("", new File("src/main/webapp"),getAbsolutePath());
          WebResourceRoot resources = new StandardRoot(ctx);
          resources.addPreResources(new DirResourceSet(resources, "/WEB-INF/classes", new File("target/classes").getAbsolutePath(), "/"));
          ctx.setResources(resources);
          tomcat.start();
          tomcat.getServer().await();
      }
  }
#+END_SRC

如此，我们直接运行 =main()= 方法，即可启动嵌入式 Tomcat 服务器，

后，通过预设的 =tomcat.addWebapp("", new File("src/main/webapp")= ，Tomcat 会自动加载当前工程作为根 webapp，可直接在浏览器访问 http://localhost:8080/：

#+BEGIN_EXPORT html
<img
src="/images/java/java-32.png"
width=""
height=""
style=""
title=""
/>
#+END_EXPORT

通过 =main()= 方法启动 Tomcat 服务器并加载我们自己的 webapp 有如下好处：
1. 启动简单，无需下载 Tomcat 或安装任何 IDE 插件；
2. 高度方便，可在 IDE 中使用断点调试；
3. 使用 Maven 创建 war 包后，也可以正常部署到独立的 Tomcat 服务器中。

#+BEGIN_EXPORT html
<essay>
看吧，你需要做一些基础的东西，才能在此基础上理方便地处理事物。
</essay>
#+END_EXPORT

对 SpringBoot 有所了解的童鞋可能知道，SpringBoot 也支持在 =main()= 方法中一行代码直接启动 Tomcat，并且还能方便地更换成 Jetty 等其他服务器，它的启动方式和我们介绍的是基本一样的。

#+BEGIN_EXPORT html
<essay>
幸运地是，许多繁琐的事情都已经有了比较成熟的解决方式，但是为什么采取这些方式，以及它们的优缺点还是需要了然于胸的。
</essay>
#+END_EXPORT

** Servlet 是什么

好的，下面我们就来具体认识一下 Servlet 是什么。

#+BEGIN_EXPORT html
<img
src="/images/java/java-33.jpg"
width="200"
height=""
style="float: left;margin-right: 10px;"
title=""
/>
#+END_EXPORT

Servlet 是 Server Applet 的简称，译为“服务器端小程序”。它是 Java 的一套技术标准，规定了如何使用 Java 来开发动态网站。换句话说，Java 可以用来开发网站后台，但是要提前定义好一套规范，并编写基础类库，这就是 Servlet 所做的事情。

Java Servlet 可以使用所有的 Java API ，Java 能做的事情，Servlet 都能做。

#+BEGIN_QUOTE
Servlet 只是古老的 CGI 技术的替代品，然而直接使用 Servlet 开发还是很麻烦，所以 Java 后来又对 Servlet 进行了升级，推出了 JSP 技术。本质上，JSP 只是对 Servlet 加了一层壳，JSP 经过编译后还是 Servlet 。
#+END_QUOTE。

#+BEGIN_EXPORT html
<essay>
程序嘛，最终都是要变为二进制的 0 和 1 ，所以，一切不过都是抽象，一层一层的抽象罢了。
</essay>
#+END_EXPORT

Servlet 是 Java Servlet 的简称，是使用 Java 语言编写的运行在服务器端的程序，具有独立平台和协议的特性，主要功能在于交互式地浏览和生成数据，生成动态 Web 内容。

*通常来说，Servlet 是指所有实现了 Servlet 接口的类。*

- Servlet 主要用于处理客户端传来的 HTTP 请求，并返回一个响应，它能够处理的请求有 =doGet()= 和 =doPost()= 等；
- Servlet 由 Servlet 容器提供，所谓 Servlet 容器就是指提供了 Servlet 功能的服务器（如 Tomcat）；
- Servlet 容器会将 Servlet 动态加载到服务器上，然后通过 HTTP 请求和 HTTP 响应与客户端进行交互。

Servlet 应用程序的体系结构如下：

#+BEGIN_EXPORT html
<img
src="/images/java/java-34.gif"
width=""
height=""
style=""
title=""
/>
#+END_EXPORT

如上图中，Servlet 的请求首先会被 HTTP 服务器（如 Apache、Nginx）接收，HTTP 服务器只负责静态 HTML 页面的解析，而 Servlet 的请求会转交给 Servlet 容器，Servlet 容器会根据 =web.xml= 文件中的映射关系，调用相应的 Servlet ，Servlet 再将处理的结果返回给 Servlet 容器，并通过 HTTP 服务器将响应传输给客户端。

** 与 Servlet 相关的接口和类

SUN 公司提供了一系列的接口和类用于 Servlet 技术的开发（缅怀一下 SUN 公司吧），其中最重要的接口是 =javax.servlet.Servlet= 。在 Servlet 接口中定义了 5 个抽象方法，如下表：
#+CAPTION: Servlet 接口的抽象方法
| 方法声明                                                         | 功能描述                                                                                                                                               |
|------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------|
| =void init(ServletConfig config)=                                | 容器在创建好 Servlet 对象后，就会调用此方法。该方法接收一个 ServletConfig 类型的参数，Servlet 容器通过该参数向 Servlet 传递初始化配置信息              |
| =ServletConfig getServletConfig()=                               | 用于获取 Servlet 对象的配置信息，返回 Servlet 的 =ServletConfig= 对象                                                                                  |
| =String getServletInfo()=                                        | 返回一个字符串，其中包含关于 Servlet 的信息，如作者、版本和版权等信息                                                                                  |
|------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------|
| =void service(ServletRequest request, ServletResponse response)= | 负责响应用户的请求，当容器接收到客户端访问 Servlet 对象的请求时，就会调用此方法。                                                                      |
|                                                                  | 容器会构造一个表示客户端请求信息的 =ServletRequest= 对象和一个用于响应客户端的 =ServletResponse= 对象作为参数传递给 =service()= 方法。                 |
|                                                                  | 在 =service()= 方法中，可以通过 =ServletRequest= 对象得到客户端的相关信息和请求信息，在对请求进行处理后，调用 =ServletResponse= 对象的方法设置响应信息 |
|------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------|
| =void destroy()=                                                 | 负责释放 Servlet 对象占用的资源，当服务器关闭或者 Servlet 对象被移除时，Servlet 对象会被销毁，容器会调用此方法                                         |

在表中，列举了 Servlet 接口中的五个方法，其中 =init()、service()= 和 =destroy()= 方法可以表现 Servlet 的生命周期，它们会在某个特定的时刻被调用。

针对 Servlet 的接口，SUN 公司提供了现个默认的接口实现类： =GenericServlet= 和 =HttpServlet= 。其中：
- =GenericServlet= 是一个抽象类，该类为 Servlet 接口提供了部分实现，它并没有实现 HTTP 请求处理；
- =HttpServlet= 是 =GenericServlet= 的子类，它继承了 =GenericServlet= 的所有方法，并且为 HTTP 请求中的 GET 和 POST 等类型提供了具体的操作方法。

*注：通常情况下，编写的 Servlet 类都继承自 =HttpServlet= ，在开发中使用的也是 =HttpServlet= 对象。

#+CAPTION: HttpServlet 类的常用方法
| 方法声明                                                                  | 功能描述                             |
|---------------------------------------------------------------------------+--------------------------------------|
| =protected void doGet(HttpServletRequest req, HttpServletResponse resp)=  | 用于处理 GET 类型的 HTTP 请求的方法  |
| =protected void doPost(HttpServletRequest req, HttpServletResponse resp)= | 用于处理 POST 类型的 HTTP 请求的方法 |

HttpServlet 主要有两大功能，具体如下：
- 根据用户请求方式的不同，定义相应的 =doXxx()= 方法处理用户请求，例如，与 GET 请求方式对应的 =doGet()= 方法，与 POST 方式对应的 =doPost()= 方法；
- 通过 =service()= 方法将 HTTP 请求和响应分别强转为 =HttpServletRequest= 和 =HttpServletResponse= 类型的对象。

需要注意的是，由于 HttpServlet 类在重写的 =service()= 方法，为每一种 HTTP 请求方式都定义了对应的 =doXxx()= 方法，因此，当定义的类的继承 HttpServlet 后，只需要根据请求方式重写对应的 =doXxx()= 方法即可，而不需要重写 =service()= 方法。

* Footnotes

[fn:1] https://www.liaoxuefeng.com/wiki/1252599548343744/1304265903570978
