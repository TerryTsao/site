<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2020-11-03 Tue 12:38 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Cross Domain</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Jack Liu">
<link rel="shortcut icon" href="/images/rose-red.png" type="image/x-icon" />
<link rel="stylesheet" href="/css/animate.min.css" />
<link rel="stylesheet" href="/css/all.min.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css" />
<script src="/js/jquery.min.js"></script>
<script src="/js/darkreader.js"></script>
<script src="/user.config.js"></script>
<script src="/js/main.js"></script>
</head>
<body>
<div id="content">
<h1 class="title">Cross Domain</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org3edf0e4">什么是跨域</a></li>
<li><a href="#org797b50b">Cookie</a></li>
<li><a href="#org153b55f">iframe</a>
<ul>
<li><a href="#org2b6e510">片段识别符</a></li>
<li><a href="#org3d1792c">window.name</a></li>
<li><a href="#org7803c30">window.postMessage</a></li>
</ul>
</li>
<li><a href="#org3504bdb">AJAX</a>
<ul>
<li><a href="#org1df0b52">JSONP</a></li>
<li><a href="#org691f0db">WebSocket</a></li>
<li><a href="#org52b5de4">CORS</a></li>
</ul>
</li>
<li><a href="#org907204a"><span class="todo TODO">TODO</span> CORS 详解</a></li>
</ul>
</div>
</div>
<p>
→ 本文摘录自 <a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">浏览器同源政策及其规避方法</a>
</p>

<div id="outline-container-org3edf0e4" class="outline-2">
<h2 id="org3edf0e4">什么是跨域</h2>
<div class="outline-text-2" id="text-org3edf0e4">
<p>
<span class="underline">跨域</span> ，是指浏览器不能执行其他网站的脚本，它是浏览器的同源策略造成的，是浏览器对 JavaScript 实施的安全限制。
</p>

<p>
那么，什么是同源策略呢？
</p>

<p>
<span class="underline">同源策略</span> 是由 Netscape 公司于 1995 年引入浏览器的，目前，所有浏览器都实行这个策略。同源策略的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。
</p>

<p>
最初，它的含义是，A 网页设置的 Cookie ，B 网页不能打开，除非这两个网页“同源” &#x2013; <span class="underline">协议相同、域名相同、端口相同</span> 。
</p>

<note>
Cookie 往往用来保存用户的登录状态，所以“同源策略”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。
</note>

<p>
随着互联网的发展，“同源策略”越来越严格。目前，如果非同源，共有三种行为受到限制：
</p>
<ol class="org-ol">
<li>Cookie、LocalStorage 和 IndexDB 无法读取；</li>
<li>DOM 无法获得；</li>
<li>AJAX 请求不能发送。</li>
</ol>

<p>
跨域的限制当然是有必要的，但实际应用过程中也常常需要在保证相对安全的情况下规避上述的三种限制。
</p>
</div>
</div>

<div id="outline-container-org797b50b" class="outline-2">
<h2 id="org797b50b">Cookie</h2>
<div class="outline-text-2" id="text-org797b50b">
<p>
Cookie 是服务器写入浏览器的一小段信息，只有同源网页才能共享。但是，如果两个网页的一级域名相同，只是二级域名不同，浏览器允许通过设置 <code>document.domain</code> 共享 Cookie 。
</p>

<p>
举例来说，A 网页是 <code>http://w1.example.com/a.html</code> ，B 网页是 <code>http://w2.example.com/b.html</code> ，那么只要设置相同的 <code>document.domain</code> ，两个网页就可以共享 Cookie 。
</p>

<div class="org-src-container">
<pre class="src src-js">document.domain = <span style="color: #E6DB74;">'example.com'</span>;
</pre>
</div>

<p>
现在，A 网页通过脚本设置一个 Cookie ：
</p>

<div class="org-src-container">
<pre class="src src-js">document.cookie = <span style="color: #E6DB74;">"test1=hello"</span>;
</pre>
</div>

<p>
B 网页就可以读到这个 Cookie ：
</p>

<div class="org-src-container">
<pre class="src src-js"><span style="color: #F92672;">var</span> <span style="color: #FD971F;">allCookie</span> = document.cookie;
</pre>
</div>

<p>
*注：这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法（要使用 PostMessage API）。
</p>

<p>
另外，服务器也可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名，比如 <code>.example.com</code> ：
</p>

<pre class="example">
Set-Cookie: key=value; domain=.example.com; path=/
</pre>

<p>
如此，二级域名和三级域名不用做任何设置，都可以读取这个 Cookie 。
</p>
</div>
</div>

<div id="outline-container-org153b55f" class="outline-2">
<h2 id="org153b55f">iframe</h2>
<div class="outline-text-2" id="text-org153b55f">
<p>
如果两个网页不同源，就无法拿到对方的 DOM ，典型的例子是 <code>iframe</code> 窗口和 <code>window.open</code> 方法打开的窗口，它们与父窗口无法通信。
</p>

<p>
如果两个窗口一级域名相同，只是二级域名不同，那么设置 <code>document.domain</code> 属性，就可以规避同源策略，拿到 DOM 。
</p>

<p>
对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题：
</p>
<ul class="org-ul">
<li>片段识别符（fragment identifier）；</li>
<li>window.name ；</li>
<li>跨文档通信 API （Cross-document messaging）。</li>
</ul>
</div>

<div id="outline-container-org2b6e510" class="outline-3">
<h3 id="org2b6e510">片段识别符</h3>
<div class="outline-text-3" id="text-org2b6e510">
<p>
<span class="underline">片段识别符</span> （fragment identifier），是指 URL 的 <code>#</code> 号后面的部分，如 <code>http://example.com/x.html#fragment</code> 的 <code>#fragment</code> 。如果，只是改变片段识别符，页面不会重新刷新。
</p>

<p>
父窗口可以把信息，写入子窗口的片段识别符，如下：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span><span style="color: #F92672;">var</span> <span style="color: #FD971F;">src</span> = originURL + <span style="color: #E6DB74;">'#'</span> + data;
<span class="linenr">2: </span>document.getElementById<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">'myIFrame'</span><span style="color: #AE81FF;">)</span>.src = src;
</pre>
</div>

<p>
子窗口通过监听 <code>hashchange</code> 事件得到通知，如下：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span>window.onhashchange = checkMessage;
<span class="linenr">2: </span>
<span class="linenr">3: </span><span style="color: #F92672;">function</span> <span style="color: #A6E22E;">checkMessage</span><span style="color: #AE81FF;">()</span> <span style="color: #AE81FF;">{</span>
<span class="linenr">4: </span>    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">message</span> = window.location.hash;
<span class="linenr">5: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">...</span>
<span class="linenr">6: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
同样的，子窗口也可以改变父窗口的片段标识符：
</p>

<div class="org-src-container">
<pre class="src src-js">parent.location.href = target + <span style="color: #E6DB74;">'#'</span> + hash;
</pre>
</div>
</div>
</div>

<div id="outline-container-org3d1792c" class="outline-3">
<h3 id="org3d1792c">window.name</h3>
<div class="outline-text-3" id="text-org3d1792c">
<p>
浏览器窗口有 <code>window.name</code> 属性，它的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页就可以读取它。
</p>

<p>
来看一个具体的例子吧。
</p>

<p>
父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入 <code>window.name</code> 属性，如下：
</p>

<div class="org-src-container">
<pre class="src src-js">window.name = data;
</pre>
</div>

<p>
接着，子窗口跳回一个与主窗口同域的网址：
</p>

<div class="org-src-container">
<pre class="src src-js">location = <span style="color: #E6DB74;">'http://parent.url.com/xxx.html'</span>;
</pre>
</div>

<p>
然后，主窗口就可以读取子窗口的 <code>window.name</code> 了：
</p>

<div class="org-src-container">
<pre class="src src-js"><span style="color: #F92672;">var</span> <span style="color: #FD971F;">data</span> = document.getElementById<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">'myFrame'</span><span style="color: #AE81FF;">)</span>.contentWindow.name;
</pre>
</div>

<p>
这种方法的优点是， <code>window.name</code> 容量很大，可以放置非常长的字符串；缺点是必须监听子窗口 <code>window.name</code> 属性的变化，影响网页性能。
</p>

<essay>
不强制兼容 IE 的话，实在不想碰这玩意儿...
</essay>
</div>
</div>

<div id="outline-container-org7803c30" class="outline-3">
<h3 id="org7803c30">window.postMessage</h3>
<div class="outline-text-3" id="text-org7803c30">
<p>
片段识别符和 <code>window.name</code> 两种方法都属于破解，HTML5 为了解决这个问题，引入了一个全新的 API &#x2013; 跨文档通信 API （Cross-document messaging）。
</p>

<p>
这个 API 为 <code>window</code> 对象新增了一个 <code>window.postMessage</code> 方法，允许跨窗口通信，不论这两个窗口是否同源。
</p>

<p>
父窗口 <code>http://aaa.com</code> 向子窗口 <code>http://bbb.com</code> 发消息，调用 <code>postMessage</code> 方法就可以了，如下：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span><span style="color: #F92672;">var</span> <span style="color: #FD971F;">popup</span> = window.open<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">'http://bbb.com'</span>, <span style="color: #E6DB74;">'title'</span><span style="color: #AE81FF;">)</span>;
<span class="linenr">2: </span>popup.postMessage<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">'Hello World!'</span>, <span style="color: #E6DB74;">'http://bbb.com'</span><span style="color: #AE81FF;">)</span>;
</pre>
</div>

<p>
其中， <code>postMessage</code> 方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即“协议 + 域名 + 端口”，也可以设为 <code>*</code> ，表示不限制域名，向所有窗口发送。
</p>

<p>
子窗口向父窗口发送消息的写法类似：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span>window.opener.postMessage<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">'Nice to see you'</span>, <span style="color: #E6DB74;">'http://aaa.com'</span><span style="color: #AE81FF;">)</span>;
</pre>
</div>

<p>
父窗口和子窗口都可以通过 <code>message</code> 事件，监听对方的消息：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span>window.addEventListener<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">'message'</span>, <span style="color: #F92672;">function</span><span style="color: #66D9EF;">(</span><span style="color: #FD971F;">e</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">2: </span>    console.log<span style="color: #A6E22E;">(</span>e.data<span style="color: #A6E22E;">)</span>;
<span class="linenr">3: </span><span style="color: #66D9EF;">}</span>, <span style="color: #AE81FF;">false</span><span style="color: #AE81FF;">)</span>;
</pre>
</div>

<blockquote>
<p>
<code>message</code> 事件的事件对象 <code>event</code> ，提供了以下三个属性：
</p>
<ul class="org-ul">
<li><code>event.source</code> ：发送消息的窗口；</li>
<li><code>event.origin</code> ：消息发向的网址；</li>
<li><code>event.data</code> ：消息内容。</li>
</ul>
</blockquote>

<p>
下面的例子是，子窗口通过 <code>event.source</code> 属性引用父窗口，然后发消息，如下：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span>window.addEventListener<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">'message'</span>, receiveMessage<span style="color: #AE81FF;">)</span>;
<span class="linenr">2: </span>
<span class="linenr">3: </span><span style="color: #F92672;">function</span> <span style="color: #A6E22E;">receiveMessage</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">event</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span>
<span class="linenr">4: </span>    event.source.postMessage<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">'Nice to see you!'</span>, <span style="color: #E6DB74;">'*'</span><span style="color: #66D9EF;">)</span>;
<span class="linenr">5: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
<code>event.origin</code> 属性可以过滤不是发给本窗口的消息：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr"> 1: </span>window.addEventListener<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">'message'</span>, receiveMessage<span style="color: #AE81FF;">)</span>;
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #F92672;">function</span> <span style="color: #A6E22E;">receiveMessage</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">event</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 4: </span>    <span style="color: #F92672;">if</span> <span style="color: #66D9EF;">(</span>event.origin !== <span style="color: #E6DB74;">'http://aaa.com'</span><span style="color: #66D9EF;">)</span> <span style="color: #F92672;">return</span>;
<span class="linenr"> 5: </span>    <span style="color: #F92672;">if</span> <span style="color: #66D9EF;">(</span>event.data === <span style="color: #E6DB74;">'Hello World'</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 6: </span>        event.source.postMessage<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">'Hello'</span>, event.origin<span style="color: #A6E22E;">)</span>;
<span class="linenr"> 7: </span>    <span style="color: #66D9EF;">}</span> <span style="color: #F92672;">else</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 8: </span>        console.log<span style="color: #A6E22E;">(</span>event.data<span style="color: #A6E22E;">)</span>;
<span class="linenr"> 9: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">10: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
<b>通过 <code>window.postMessage</code> ，读写其他窗口的 LocalStorage 也成为了可能。</b>
</p>

<p>
例如，主窗口写入 iframe 子窗口的 <code>localStorage</code> ：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span>window.onmessage = <span style="color: #F92672;">function</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">e</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span>
<span class="linenr">2: </span>    <span style="color: #F92672;">if</span> <span style="color: #66D9EF;">(</span>e.origin !== <span style="color: #E6DB74;">'http://bbb.com'</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">3: </span>        <span style="color: #F92672;">return</span>;
<span class="linenr">4: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">5: </span>
<span class="linenr">6: </span>    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">payload</span> = JSON.parse<span style="color: #66D9EF;">(</span>e.data<span style="color: #66D9EF;">)</span>;
<span class="linenr">7: </span>    localStorage.setItem<span style="color: #66D9EF;">(</span>payload.key, JSON.stringfy<span style="color: #A6E22E;">(</span>payload.data<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>; <span style="color: #75715E;">// </span><span style="color: #75715E;">?? payload.data</span>
<span class="linenr">8: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
其中，父窗口发送消息的代码如下：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span><span style="color: #F92672;">var</span> <span style="color: #FD971F;">win</span> = document.getElementByTagName<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">'iframe'</span><span style="color: #AE81FF;">)[</span>0<span style="color: #AE81FF;">]</span>.contentWindow;
<span class="linenr">2: </span><span style="color: #F92672;">var</span> <span style="color: #FD971F;">obj</span> = <span style="color: #AE81FF;">{</span> name: <span style="color: #E6DB74;">'Jack'</span> <span style="color: #AE81FF;">}</span>;
<span class="linenr">3: </span>
<span class="linenr">4: </span>win.postMessage<span style="color: #AE81FF;">(</span>JSON.stringfy<span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">{</span> key: <span style="color: #E6DB74;">'storage'</span>, data: obj <span style="color: #A6E22E;">}</span><span style="color: #66D9EF;">)</span>, <span style="color: #E6DB74;">'http://bbb.com'</span><span style="color: #AE81FF;">)</span>;
</pre>
</div>

<essay>
下面来个加强版的...
</essay>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr"> 1: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#21152;&#24378;&#29256;&#30340;&#29238;&#31383;&#21475;&#21457;&#28040;&#24687; ///</span>
<span class="linenr"> 2: </span><span style="color: #F92672;">var</span> <span style="color: #FD971F;">win</span> = doucment.getElementByTagName<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">'iframe'</span><span style="color: #AE81FF;">)[</span>0<span style="color: #AE81FF;">]</span>.contentWindow;
<span class="linenr"> 3: </span><span style="color: #F92672;">var</span> <span style="color: #FD971F;">obj</span> = <span style="color: #AE81FF;">{</span> name: <span style="color: #E6DB74;">'Jack'</span> <span style="color: #AE81FF;">}</span>;
<span class="linenr"> 4: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#23384;&#20837;&#23545;&#35937;</span>
<span class="linenr"> 5: </span>win.postMessage<span style="color: #AE81FF;">(</span>JSON.stringfy<span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">{</span> key: <span style="color: #E6DB74;">'storage'</span>, method: <span style="color: #E6DB74;">'set'</span>, data: obj <span style="color: #A6E22E;">}</span><span style="color: #66D9EF;">)</span>, <span style="color: #E6DB74;">'http://bbb.com'</span><span style="color: #AE81FF;">)</span>;
<span class="linenr"> 6: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#35835;&#21462;&#23545;&#35937;</span>
<span class="linenr"> 7: </span>win.postMessage<span style="color: #AE81FF;">(</span>JSON.stringfy<span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">{</span> key: <span style="color: #E6DB74;">'storage'</span>, method: <span style="color: #E6DB74;">'get'</span><span style="color: #A6E22E;">}</span><span style="color: #66D9EF;">)</span>, <span style="color: #E6DB74;">'*'</span><span style="color: #AE81FF;">)</span>;
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>window.onmessage = <span style="color: #F92672;">function</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">e</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span>
<span class="linenr">10: </span>    <span style="color: #F92672;">if</span> <span style="color: #66D9EF;">(</span>e.origin != <span style="color: #E6DB74;">'http://aaa.com'</span><span style="color: #66D9EF;">)</span> <span style="color: #F92672;">return</span>;
<span class="linenr">11: </span>    console.log<span style="color: #66D9EF;">(</span>JSON.parse<span style="color: #A6E22E;">(</span>e.data<span style="color: #A6E22E;">)</span>.name<span style="color: #66D9EF;">)</span>; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; "Jack"</span>
<span class="linenr">12: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr"> 1: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#21152;&#24378;&#29256;&#30340;&#23376;&#31383;&#21475;&#25509;&#25910;&#28040;&#24687; ///</span>
<span class="linenr"> 2: </span>window.onmessage = <span style="color: #F92672;">function</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">e</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 3: </span>    <span style="color: #F92672;">if</span> <span style="color: #66D9EF;">(</span>e.origin !== <span style="color: #E6DB74;">'http://bbb.com'</span><span style="color: #66D9EF;">)</span> <span style="color: #F92672;">return</span>;
<span class="linenr"> 4: </span>    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">payload</span> = JSON.parse<span style="color: #66D9EF;">(</span>e.data<span style="color: #66D9EF;">)</span>;
<span class="linenr"> 5: </span>    <span style="color: #F92672;">switch</span> <span style="color: #66D9EF;">(</span>payload.method<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 6: </span>        <span style="color: #F92672;">case</span> <span style="color: #E6DB74;">'set'</span>:
<span class="linenr"> 7: </span>            localStorage.setItem<span style="color: #A6E22E;">(</span>payload.key, JSON.stringfy<span style="color: #E6DB74;">(</span>payload.data<span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">)</span>;
<span class="linenr"> 8: </span>            <span style="color: #F92672;">break</span>;
<span class="linenr"> 9: </span>        <span style="color: #F92672;">case</span> <span style="color: #E6DB74;">'get'</span>:
<span class="linenr">10: </span>            <span style="color: #F92672;">var</span> <span style="color: #FD971F;">parent</span> = window.parent;
<span class="linenr">11: </span>            <span style="color: #F92672;">var</span> <span style="color: #FD971F;">data</span> = localStorage.getItem<span style="color: #A6E22E;">(</span>payload.key<span style="color: #A6E22E;">)</span>;
<span class="linenr">12: </span>            parent.postMessage<span style="color: #A6E22E;">(</span>data, <span style="color: #E6DB74;">'http://aaa.com'</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">13: </span>            <span style="color: #F92672;">break</span>;
<span class="linenr">14: </span>        <span style="color: #F92672;">case</span> <span style="color: #E6DB74;">'remove'</span>:
<span class="linenr">15: </span>            localStorage.removeItem<span style="color: #A6E22E;">(</span>payload.key<span style="color: #A6E22E;">)</span>;
<span class="linenr">16: </span>            <span style="color: #F92672;">break</span>;
<span class="linenr">17: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">18: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3504bdb" class="outline-2">
<h2 id="org3504bdb">AJAX</h2>
<div class="outline-text-2" id="text-org3504bdb">
<p>
同源政策规定，AJAX 请求只能发给同源的网址，否则就报错。
</p>

<p>
除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制： <span class="underline">JSONP、WebSocket、CORS</span> 。
</p>

<note>
这里架设的服务器是用来代理客户端的，是正向代理。
</note>
</div>

<div id="outline-container-org1df0b52" class="outline-3">
<h3 id="org1df0b52">JSONP</h3>
<div class="outline-text-3" id="text-org1df0b52">
<p>
JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。
</p>

<p>
<b>JSONP 的基本思想是什么？</b>
</p>

<p>
原来，网页通过添加一个 <code>&lt;script&gt;</code> 元素，向服务器请求 JSON 数据的做法是不受同源策略限制的；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。
</p>

<p>
首先，网页动态插入 <code>&lt;script&gt;</code> 元素，由它向跨源网址发出请求，如下：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr"> 1: </span><span style="color: #F92672;">function</span> <span style="color: #A6E22E;">addScriptTag</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">src</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">script</span> = doucment.createElement<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">'script'</span><span style="color: #66D9EF;">)</span>;
<span class="linenr"> 3: </span>    script.setAttribute<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">'type'</span>, <span style="color: #E6DB74;">'text/javascript'</span><span style="color: #66D9EF;">)</span>;
<span class="linenr"> 4: </span>    script.src = src;
<span class="linenr"> 5: </span>    document.body.appendChild<span style="color: #66D9EF;">(</span>script<span style="color: #66D9EF;">)</span>;
<span class="linenr"> 6: </span><span style="color: #AE81FF;">}</span>
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>window.onload = <span style="color: #F92672;">function</span><span style="color: #AE81FF;">()</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 9: </span>    addScriptTag<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">'http://example.com/jp?callback=foo'</span><span style="color: #66D9EF;">)</span>;
<span class="linenr">10: </span><span style="color: #AE81FF;">}</span>
<span class="linenr">11: </span>
<span class="linenr">12: </span><span style="color: #F92672;">function</span> <span style="color: #A6E22E;">foo</span><span style="color: #AE81FF;">(</span><span style="color: #FD971F;">data</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span>
<span class="linenr">13: </span>    console.log<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">'Your public IP address is: '</span> + data.ip<span style="color: #66D9EF;">)</span>;
<span class="linenr">14: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
上述代码通过动态添加 <code>&lt;script&gt;</code> 元素，向服务器 <code>example.com</code> 发出请求。
</p>

<p>
<b>*注：该请求的查询字符串有一个 <code>callback</code> 参数，用来指定回调函数的名字，在对于 JSONP 是必需的。</b>
</p>

<p>
服务器收到这个请求后，会将数据放在回调函数的参数位置返回，如下：
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="linenr">1: </span>foo<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">{</span>
<span class="linenr">2: </span>    <span style="color: #E6DB74;">'ip'</span>: <span style="color: #E6DB74;">'8.8.8.8'</span>
<span class="linenr">3: </span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>;
</pre>
</div>

<p>
由于 <code>&lt;script&gt;</code> 元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了 <code>foo</code> 函数，该函数就会立即调用。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用 <code>JSON.parse</code> 的步骤。
</p>
</div>
</div>

<div id="outline-container-org691f0db" class="outline-3">
<h3 id="org691f0db">WebSocket</h3>
<div class="outline-text-3" id="text-org691f0db">
<p>
WebSocket 是一种通信协议，使用 <code>ws://</code> （非加密）和 <code>wss://</code> （加密）作为协议前缀。该协议不实行同源策略，只要服务器支持，就可以通过它进行跨源通信。
</p>

<p>
来看个例子，下面是浏览器发出的 WebSocket 请求的头信息：
</p>

<pre class="example">
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
</pre>

<p>
其中， <code>Origin</code> 表示该请求的请求源（origin），即发自哪个域名。
</p>

<blockquote>
<p>
正是因为有了 <code>Origin</code> 这个字段，WebSocket 才没有实行同源策略，因为服务器可以根据这个字段，判断是否允许本次通信。
</p>
</blockquote>

<p>
如果该域名在白名单内，服务器就会做出如下响应：
</p>

<pre class="example">
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
</pre>
</div>
</div>

<div id="outline-container-org52b5de4" class="outline-3">
<h3 id="org52b5de4">CORS</h3>
<div class="outline-text-3" id="text-org52b5de4">
<p>
CORS （Cross-Origin Resource Sharing）是跨域资源分享的缩写，它是 W3C 标准，是 <b>跨源 AJAX 请求的根本解决办法</b> 。相比 JSONP 只能发 <code>GET</code> 请求，CORS 允许任何类型的请求。
</p>
</div>
</div>
</div>

<div id="outline-container-org907204a" class="outline-2">
<h2 id="org907204a"><span class="todo TODO">TODO</span> CORS 详解</h2>
<div class="outline-text-2" id="text-org907204a">
<p>
CORS 允许浏览器向跨源服务器，发出 <code>XMLHttpRequest</code> 请求，从而克服了 AJAX 只能同源使用的限制。接下来，我们来深入认识下 CORS 的内部机制。
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2020-11-03 Tue 09:36</p>
<p class="author">Author: Jack Liu</p>
<p class="date">Created: 2020-11-03 Tue 12:38</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
