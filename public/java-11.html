<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2020-09-30 Wed 19:06 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>集合、泛型和枚举</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Jack Liu">
<link rel="shortcut icon" href="/images/rose-red.png" type="image/x-icon" />
<link rel="stylesheet" href="/css/animate.min.css" />
<link rel="stylesheet" href="/css/all.min.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css" />
<script src="/js/jquery.min.js"></script>
<script src="/js/darkreader.js"></script>
<script src="/user.config.js"></script>
<script src="/js/main.js"></script>
</head>
<body>
<div id="content">
<h1 class="title">集合、泛型和枚举</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org6e466a1">集合</a></li>
<li><a href="#org401567d">Colletion 接口</a></li>
<li><a href="#orgb6069a5">List 集合</a>
<ul>
<li><a href="#orgf1e4b5d">ArrayList 类</a></li>
<li><a href="#org2cccfb1">LinkedList 类</a></li>
<li><a href="#org1f66393">ArrayList VS LinkedList</a></li>
</ul>
</li>
<li><a href="#orgfd946f1">Set 集合</a>
<ul>
<li><a href="#orga84d8c7">HashSet 类</a></li>
<li><a href="#org411ad71">TreeSet 类</a></li>
</ul>
</li>
<li><a href="#org14f4e61">Map 集合</a></li>
<li><a href="#org4cfe5ee"><span class="todo TODO">TODO</span> Collections 类</a></li>
<li><a href="#org5ce4b13">泛型</a>
<ul>
<li><a href="#org9c583b1">泛型集合</a></li>
<li><a href="#orga8101d4">泛型类</a></li>
<li><a href="#org89c270a">泛型方法</a></li>
<li><a href="#orgf317e0d"><span class="todo TODO">TODO</span> 泛型的高级用法</a></li>
</ul>
</li>
<li><a href="#org4f15560">图书信息查询</a></li>
</ul>
</div>
</div>
<p>
Java 的集合就像一个容器，用来存储 Java 类的对象。
</p>

<div id="outline-container-org6e466a1" class="outline-2">
<h2 id="org6e466a1">集合</h2>
<div class="outline-text-2" id="text-org6e466a1">
<p>
在编程时，可以使用数组来保存多个对象，但数组长度一旦指定就不可变化，而且数组无法保存具有映射关系的数据。
</p>

<p>
为了保存数量不确定的数据，以及保存具有映射关系的数据（也被称为关联数组），Java 提供了集合类。
</p>

<p>
集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。Java 所有的集合类都位于 <code>java.util</code> 包下，提供了一个表示和操作对象集合的统一构架，包含了大量集合接口，以及这些接口的实现类和操作的算法。
</p>

<p>
集合类和数组不一样，数组元素既可以是基本类型的值，也可以是对象（实际上保存的是对象的引用变量），而集合里只能保存对象。
</p>

<p>
Java 集合类型分为 <code>Collection</code> 和 <code>Map</code> ，它们是 Java 集合的根接口，这两个接口又包含了一些子接口或实现类。
</p>

<div class="figure">
<p><img src="../images/java/java-8.png" alt="java-8.png">
</p>
<p><span class="figure-number">Figure 1: </span>Collection 接口基本结构</p>
</div>

<img
src="/images/java/java-9.png"
width="500"
height=""
style=""
title=""
/>
<p>
<code>Figure 2: Map 接口基本结构</code>
</p>

<p>
*注：上图中，黄色块为集合的接口，蓝色为集合的实现类。
</p>

<table>
<caption class="t-above"><span class="table-number">Table 1:</span> Java 集合接口的作用</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">接口名称</th>
<th scope="col" class="org-left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>Iterator</code></td>
<td class="org-left">集合的输出接口，主要用于遍历输出（即迭代访问） <code>Collection</code> 集合中的元素， <code>Iterator</code> 对象被称之为迭代器。迭代器接口是集合接口的父接口，实现类实现 <code>Collection</code> 时就必须实现 <code>Iterator</code> 接口。</td>
</tr>

<tr>
<td class="org-left"><code>Collection</code></td>
<td class="org-left">是 <code>List、Set</code> 和 <code>Queue</code> 的父接口，是存放一组单值的最大接口。所谓的单值是指集合中的每个元素都是一个对象，一般很少使用此接口直接操作。</td>
</tr>

<tr>
<td class="org-left"><code>Queue</code></td>
<td class="org-left"><code>Queue</code> 是 Java 提供的队列实现，有点类似于 <code>List</code> 。</td>
</tr>

<tr>
<td class="org-left"><code>Dueue</code></td>
<td class="org-left">是 <code>Queue</code> 的一个子接口，为双向队列。</td>
</tr>

<tr>
<td class="org-left"><code>List</code></td>
<td class="org-left">是最常用的接口。是有序集合，允许有相同的元素。使用 <code>List</code> 能够精确地控制每个元素插入的位置，用户能够使用索引来访问 <code>List</code> 中的元素，与数组类似。</td>
</tr>

<tr>
<td class="org-left"><code>Set</code></td>
<td class="org-left">不能包含重复的元素。</td>
</tr>

<tr>
<td class="org-left"><code>Map</code></td>
<td class="org-left">是存放一对值的最大接口，即接口中的每个元素都是一对，以 <code>key → value</code> 的形式保存。</td>
</tr>
</tbody>
</table>

<p>
对于 <code>Set、List、Queue</code> 和 <code>Map</code> 这 4 种集合，Java 最常用的实现类分别是 <code>HashSet、TreeSet、ArrayList、ArrayDueue、LinkedList</code> 和 <code>HashMap、TreeMap</code> 等。
</p>

<table>
<caption class="t-above"><span class="table-number">Table 2:</span> Java 集合实现类的作用</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">类名称</th>
<th scope="col" class="org-left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>HashSet</code></td>
<td class="org-left">为优化查询速度而设计的 <code>Set</code> 。它是基于 <code>HashMap</code> 实现的， <code>HashSet</code> 底层使用 <code>HashMap</code> 来保存所有元素，实现比较简单。</td>
</tr>

<tr>
<td class="org-left"><code>TreeSet</code></td>
<td class="org-left">实现了 <code>Set</code> 接口，是一个有序的 <code>Set</code> ，这样就能从 <code>Set</code> 里面提取一个有序序列。</td>
</tr>

<tr>
<td class="org-left"><code>ArrayList</code></td>
<td class="org-left">一个用数组实现的 <code>List</code> ，能进行快速的随机访问，效率高而且实现了可变大小的数组。</td>
</tr>

<tr>
<td class="org-left"><code>ArrayDueue</code></td>
<td class="org-left">是一个基于数组实现的双端队列，按“先进先出”的方式操作集合元素。</td>
</tr>

<tr>
<td class="org-left"><code>LinkedList</code></td>
<td class="org-left">对顺序访问进行了优化，但随机访问的速度相对较慢。此外它还有 <code>addFirst()、addLast()、getFirst()、getLast()、removeFirst()</code> 和 <code>removeLast()</code> 等方法，能把它当成栈（ <code>Stack</code> ） 或队列（ <code>Queue</code> ）来用。</td>
</tr>

<tr>
<td class="org-left"><code>HashMap</code></td>
<td class="org-left">按哈希算法来存取键对象。</td>
</tr>

<tr>
<td class="org-left"><code>TreeMap</code></td>
<td class="org-left">可以对键对象进行排序。</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org401567d" class="outline-2">
<h2 id="org401567d">Colletion 接口</h2>
<div class="outline-text-2" id="text-org401567d">
<p>
<code>Collection</code> 接口是 <code>List、Set</code> 和 <code>Queue</code> 接口的父接口，通常情况下不被直接使用。 <code>Collection</code> 接口定义了一些通用的方法，通过这些方法可以实现对集合的基本操作，它们也可用于操作 <code>Set、List、Queue</code> 。
</p>

<essay>
List、Set、Queue 继承自 Collection 接口，自然已经实现了 Collection 接口中的方法。
</essay>

<table>
<caption class="t-above"><span class="table-number">Table 3:</span> Collection 接口的常用方法</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法名称</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>boolean add(E e)</code></td>
<td class="org-left">向集合中添加一个元素，如果集合对象被添加操作改变了，则返回 <code>true</code> 。 <code>E</code> 是元素的数据类型。</td>
</tr>

<tr>
<td class="org-left"><code>boolean addAll(Collection c)</code></td>
<td class="org-left">向集合中添加集合 <code>c</code> 中的所有元素，如果集合对象被添加操作改变了，则返回 <code>true</code> 。</td>
</tr>

<tr>
<td class="org-left"><code>void clear()</code></td>
<td class="org-left">清除集合中的所有元素，将集合长度变为 <code>0</code> 。</td>
</tr>

<tr>
<td class="org-left"><code>boolean contains(Object o)</code></td>
<td class="org-left">判断集合中是否存在指定元素</td>
</tr>

<tr>
<td class="org-left"><code>boolean containsAll(Collection c)</code></td>
<td class="org-left">判断集合中是否包含集合 c 中的所有元素</td>
</tr>

<tr>
<td class="org-left"><code>boolean isEmpty()</code></td>
<td class="org-left">判断集合是否为空</td>
</tr>

<tr>
<td class="org-left"><code>Iterator&lt;E&gt; iterator()</code></td>
<td class="org-left">返回一个 <code>Iterator</code> 对象，用于遍历集合中的元素</td>
</tr>

<tr>
<td class="org-left"><code>boolean remove(Object o)</code></td>
<td class="org-left">从集合中删除一个指定元素，当集合中包含了一个或多个元素 <code>o</code> 时，该方法 <b>只删除第一个</b> 符合条件的元素，该方法将返回 <code>true</code> 。</td>
</tr>

<tr>
<td class="org-left"><code>boolean removeAll(Collection c)</code></td>
<td class="org-left">从集合中删除所有在集合 <code>c</code> 中出现的元素（相当于把调用该方法的集合减去集合 <code>c</code> ）。如果该操作改变了调用该方法的集合，则该方法返回 <code>true</code> 。</td>
</tr>

<tr>
<td class="org-left"><code>boolean retainAll(Collection c)</code></td>
<td class="org-left">从集合中删除集合 <code>c</code> 里不包含的元素（相当于把调用该方法的集合变成该集合和集合 <code>c</code> 的交集），如果该操作改变了调用该方法的集合，则该方法返回 <code>true</code> 。</td>
</tr>

<tr>
<td class="org-left"><code>int size()</code></td>
<td class="org-left">返回集合中元素的个数</td>
</tr>

<tr>
<td class="org-left"><code>Object[] toArray()</code></td>
<td class="org-left">把集合转换为一个数组，所有的集合元素变成对应的数组元素。</td>
</tr>
</tbody>
</table>

<p>
*注： <code>retainAll()</code> 方法的作用与 <code>removeAll()</code> 方法相反，它保留两个集合中相同的元素，其他全部删除。
</p>

<p>
集合类像容器，现实生活中容器的功能，就是添加对象、删除对象、清空容器和判断容器是否为空等，集合类为这些功能提供了对应的方法。
</p>

<essay>
看，其实只要联系现实，记忆就突然变得简单了，这就是用以为学了。
</essay>

<blockquote>
<p>
在传统模式下，把一个对象“丢进”集合中后，集合会忘记这个对象的类型。也就是说，系统把所有的集合元素都当成 Object 类型。从 Java 5 以后，可以使用泛型来限制集合里元素的类型，并让集合记住所有集合元素的类型。
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgb6069a5" class="outline-2">
<h2 id="orgb6069a5">List 集合</h2>
<div class="outline-text-2" id="text-orgb6069a5">
<p>
<code>List</code> 是一个有序、可重复的集合，集合中每个元素都有其对应的顺序索引，默认按元素的添加顺序设置元素的索引，可以通过索引来访问指定位置的元素。
</p>

<p>
<code>List</code> 实现了 <code>Collection</code> 接口，它主要有两个常用的实现类： <code>ArrayList</code> 类和 <code>LinkedList</code> 类。
</p>
</div>

<div id="outline-container-orgf1e4b5d" class="outline-3">
<h3 id="orgf1e4b5d">ArrayList 类</h3>
<div class="outline-text-3" id="text-orgf1e4b5d">
<p>
<code>ArrayList</code> 类实现了可变数组的大小，存储在内的数据称为元素。它还提供了快速基于索引访问元素的方式，对 <b>尾部成员</b> 的增加和删除支持较好。
</p>

<p>
*注：向 <code>ArrayList</code> 中（除尾部成员）插入与删除元素的速度相对较慢。
</p>

<p>
<code>ArrayList</code> 类的常用构造方法有如下两种重载形式：
</p>
<ul class="org-ul">
<li><code>ArrayList()</code> ：构造一个初始容量为 10 的空列表；</li>
<li><code>ArrayList(Collection&lt;?extends E&gt; c)</code> ：构造一个包含指定 <code>Collection</code> 元素的列表，这些元素是按照 <code>Collection</code> 的迭代器返回它们的顺序排列的。</li>
</ul>

<p>
<code>ArrayList</code> 类除了包含 <code>Collection</code> 接口的所有方法之外，还包括 <code>List</code> 接口中提供的如下表所示的方法。
</p>

<table>
<caption class="t-above"><span class="table-number">Table 4:</span> ArrayList 类的常用方法</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法名称</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>E get(int index)</code></td>
<td class="org-left">获取此集合中指定索引位置的元素， <code>E</code> 为集合中元素的数据类型</td>
</tr>

<tr>
<td class="org-left"><code>E set(int index, E element)</code></td>
<td class="org-left">将此集合中指定索引位置的元素修改为 <code>element</code> 参数指定的对象。此方法返回此集合中指定索引位置的原元素</td>
</tr>

<tr>
<td class="org-left"><code>int index(Object o)</code></td>
<td class="org-left">返回此集合中第一次出现指定元素的索引，如果此集合不包含该元素，则返回 <code>-1</code></td>
</tr>

<tr>
<td class="org-left"><code>int lastIndexOf(Object o)</code></td>
<td class="org-left">返回此集合中最后一次出现指定元素的索引，如果此集合不包含该元素，则返回 <code>-1</code></td>
</tr>

<tr>
<td class="org-left"><code>List&lt;E&gt; subList(int fromIndex, int toIndex)</code></td>
<td class="org-left">返回一个新的集合，新集合中包含 <code>fromIndex</code> 和 <code>toIndex</code> 索引之间的所有元素（左闭右开）</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org2cccfb1" class="outline-3">
<h3 id="org2cccfb1">LinkedList 类</h3>
<div class="outline-text-3" id="text-org2cccfb1">
<p>
<code>LinkedList</code> 类采用链表结构保存对象，这种结构的优点是便于向集合中插入或者删除元素。
</p>

<p>
*注：需要频繁向集合中插入和删除元素时，使用 <code>LinkedList</code> 类比 <code>ArrayList</code> 类效果高，但是 <code>LinkedList</code> 类随机访问元素的速度则相对较慢。
</p>

<p>
<code>LinkedList</code> 类除了包含 <code>Collection</code> 接口中的所有方法之外，还特别提供了下表所示的方法：
</p>

<table>
<caption class="t-above"><span class="table-number">Table 5:</span> LinkList 类中的方法</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法名称</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>void addFirst(E e)</code></td>
<td class="org-left">将指定元素添加到此集合的开头</td>
</tr>

<tr>
<td class="org-left"><code>void addLast(E e)</code></td>
<td class="org-left">将指定元素添加到此集合的末尾</td>
</tr>

<tr>
<td class="org-left"><code>E getFirst()</code></td>
<td class="org-left">返回此集合的第一个元素</td>
</tr>

<tr>
<td class="org-left"><code>E getLast()</code></td>
<td class="org-left">返回此集合的最后一个元素</td>
</tr>

<tr>
<td class="org-left"><code>E removeFirst()</code></td>
<td class="org-left">删除此集合中的第一个元素</td>
</tr>

<tr>
<td class="org-left"><code>E removeLast()</code></td>
<td class="org-left">删除此集合中的最后一个元素</td>
</tr>
</tbody>
</table>

<p>
<code>LinkedList&lt;String&gt;</code> 中的 <code>&lt;String&gt;</code> 是 Java 中的泛型， <b>用于指定集合中元素的数据类型</b> ，例如这里指定元素类型为 <code>String</code> ，则该集合中不能添加非 <code>String</code> 类型的元素。
</p>
</div>
</div>

<div id="outline-container-org1f66393" class="outline-3">
<h3 id="org1f66393">ArrayList VS LinkedList</h3>
<div class="outline-text-3" id="text-org1f66393">
<p>
<code>ArrayList</code> 与 <code>LinkedList</code> 都是 <code>List</code> 接口的实现类，因此都实现了 <code>List</code> 的所有未实现的方法，只是实现的方式有所不同。
</p>

<p>
*注： <code>LinkedList</code> 类同时实现了 <code>Dueue</code> 接口和 <code>List</code> 接口。
</p>

<p>
<code>ArrayList</code> 是基于动态数组数据结构的实现，访问速度优于 <code>LinkedList</code> ； <code>LinkedList</code> 是基于链表数据结构的实现，占用的内存空间较大，但在批量插入或删除数据时优于 <code>ArrayList</code> 。
</p>

<blockquote>
<p>
不同的结构对应于不同的算法，有的考虑节省占用空间，有的考虑提高运行效率，对于程序员而言，它们就像是“熊掌”和“鱼肉”，不可兼得。高运行速度往往是以牺牲空间为代价的，而节省占用空间往往是以牺牲运行速度为代价的。
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-orgfd946f1" class="outline-2">
<h2 id="orgfd946f1">Set 集合</h2>
<div class="outline-text-2" id="text-orgfd946f1">
<p>
<code>Set</code> 集合类似于一个罐子，程序可以把多个对象“丢进” <code>Set</code> 集合，而 <code>Set</code> 集合通常不能记住元素的添加顺序。也就是说， <code>Set</code> 集合中的对象不按特定的方式排序，只是简单地把对象加入集合，它不能包含重复的对象，并且最多只允许包含一个 <code>null</code> 元素。
</p>

<p>
<code>Set</code> 实现了 <code>Collection</code> 接口，它主要有两个常用的实现类： <code>HashSet</code> 类和 <code>TreeSet</code> 类。
</p>
</div>

<div id="outline-container-orga84d8c7" class="outline-3">
<h3 id="orga84d8c7">HashSet 类</h3>
<div class="outline-text-3" id="text-orga84d8c7">
<p>
<code>HashSet</code> 是 <code>Set</code> 接口的典型实现，大多数时候使用 <code>Set</code> 集合时就是使用这个实现类。 <code>HashSet</code> 是按照 <code>Hash</code> 算法来存储集合中的元素，因此具有很好的存取和查找性能。
</p>

<p>
<code>HashSet</code> 具有以下特点：
</p>
<ul class="org-ul">
<li>不能保证元素的排列顺序，顺序可能与添加顺序不同，顺序也有可能发生变化；</li>
<li><code>HashSet</code> 不是同步的，如果多个线程同时访问或修改一个 <code>HashSet</code> ，则必须通过代码来保证其同步；</li>
<li>集合元素值可以是 <code>null</code> 。</li>
</ul>

<p>
当向 <code>HashSet</code> 集合中存入一个元素时， <code>HashSet</code> 会调用该对象的 <code>hasCode()</code> 方法来得到该对象的 <code>hasCode</code> 值，然后根据该 <code>hasCode</code> 值决定该对象在 <code>HashSet</code> 中的存储位置。
</p>

<p>
如果有两个元素通过 <code>equals()</code> 方法比较返回的结果为 <code>true</code> ，但它们的 <code>hasCode</code> 不相等， <code>HashSet</code> 将会把它们存储在不同的位置，依然可以添加成功。
</p>

<p>
也就是说，两个对象的 <code>hasCode</code> 值相等且通过 <code>equals()</code> 方法比较返回结果为 <code>true</code> ，则 <code>HashSet</code> 集合认为两个元素相等。
</p>

<p>
在 <code>HashSet</code> 类中实现了 <code>Collection</code> 接口中的所有方法， <code>HashSet</code> 类的常用构造方法重载形式如下：
</p>
<ul class="org-ul">
<li><code>HashSet()</code> ：构造一个新的空的 <code>Set</code> 集合；</li>
<li><code>HashSet(Collection&lt;? extends E&gt; c)</code> ：构造一个包含指定 <code>Collection</code> 集合元素的新 <code>Set</code> 集合。其中， <code>&lt; &gt;</code> 中的 <code>extends</code> 表示 <code>HashSet</code> 的父类，即指明该 <code>Set</code> 集合中存放的集合元素类型。 <code>c</code> 表示其中的元素将被存放在此 <code>Set</code> 集合中。</li>
</ul>

<p>
下面的代码演示了创建两种不同形式的 <code>HashSet</code> 对象：
</p>
<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #66D9EF;">HashSet</span> <span style="color: #FD971F;">hs</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">HashSet</span><span style="color: #AE81FF;">()</span>;                  <span style="color: #75715E;">// </span><span style="color: #75715E;">&#35843;&#29992;&#26080;&#21442;&#30340;&#26500;&#36896;&#20989;&#25968;&#21019;&#24314; HashSet &#23545;&#35937;</span>
<span class="linenr">2: </span><span style="color: #66D9EF;">HashSet</span><span style="color: #AE81FF;">&lt;</span><span style="color: #66D9EF;">String</span><span style="color: #AE81FF;">&gt;</span> <span style="color: #FD971F;">hss</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">HashSet</span><span style="color: #AE81FF;">&lt;</span><span style="color: #66D9EF;">String</span><span style="color: #AE81FF;">&gt;()</span>; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#21019;&#24314;&#27867;&#22411;&#30340; HashSet &#38598;&#21512;&#23545;&#35937;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org411ad71" class="outline-3">
<h3 id="org411ad71">TreeSet 类</h3>
<div class="outline-text-3" id="text-org411ad71">
<p>
<code>TreeSet</code> 类同时实现了 <code>Set</code> 接口和 <code>SortedSet</code> 接口。 <code>SortedSet</code> 接口是 <code>Set</code> 接口的子接口，可以实现对集合进行自然排序，因此使用 <code>TreeSet</code> 类实现的 <code>Set</code> 接口默认情况下是自然排序（升序排序）的。
</p>

<p>
<code>TreeSet</code> 只能对实现了 <code>Comparable</code> 接口的类对象进行排序，因为 <code>Comparable</code> 接口有一个 <code>compareTo(Object o)</code> 方法用于比较两个对象的大小。
</p>

<p>
例如 <code>a.compareTo(b)</code> ，如果 <code>a</code> 和 <code>b</code> 相等，则该方法返回 <code>0</code> ；如果 <code>a</code> 大于 <code>b</code> ，则该方法返回大于 <code>0</code> 的值；如果 <code>a</code> 小于 <code>b</code> ，则该方法返回小于 <code>0</code> 的值。
</p>

<p>
下表列举了 JDK 类库中实现 <code>Comparable</code> 接口的类，以及这些类对象的比较方式：
</p>

<table>
<caption class="t-above"><span class="table-number">Table 6:</span> 实现 Comparable 接口类对象的比较方式</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">类</th>
<th scope="col" class="org-left">比较方式</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">包装类（ <code>BigDecimal、BigInteger、Byte、Double、Float、Integer、Long</code> 及 <code>Short</code> ）</td>
<td class="org-left">按数字大小比较</td>
</tr>

<tr>
<td class="org-left"><code>Character</code></td>
<td class="org-left">按字符的 Unicode 值的数字大小比较</td>
</tr>

<tr>
<td class="org-left"><code>String</code></td>
<td class="org-left">按字符中字符的 Unicode 值的数字大小比较</td>
</tr>
</tbody>
</table>

<p>
<code>TreeSet</code> 类除了实现 <code>Collection</code> 接口的所有方法之外，还提供了如下表所示的方法：
</p>

<table>
<caption class="t-above"><span class="table-number">Table 7:</span> TreeSet 类的常用方法</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法名称</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>E first()</code></td>
<td class="org-left">返回此集合中的第一个元素。其中， <code>E</code> 表示集合中元素的数据类型。</td>
</tr>

<tr>
<td class="org-left"><code>E last()</code></td>
<td class="org-left">返回此集合中的最后一个元素</td>
</tr>

<tr>
<td class="org-left"><code>E poolFirst()</code></td>
<td class="org-left">获取并移除此集合中的第一个元素</td>
</tr>

<tr>
<td class="org-left"><code>E poolLast()</code></td>
<td class="org-left">获取并移除此集合中的最后一个元素</td>
</tr>

<tr>
<td class="org-left"><code>SortedSet&lt;E&gt; subSet(E fromElement, E toElement)</code></td>
<td class="org-left">返回一个新的集合，新集合包含原集合中 <code>fromElement</code> 对象与 <code>toElement</code> 对象之间的所有对象，左闭右开。</td>
</tr>

<tr>
<td class="org-left"><code>SortedSet&lt;E&gt; headSet&lt;E toElement&gt;</code></td>
<td class="org-left">返回一个新的集合，新集合包含原集合中 <code>toElement</code> 对象之前的所有对象，不包含 <code>toElement</code> 对象。</td>
</tr>

<tr>
<td class="org-left"><code>SortedSet&lt;E&gt; tailSet&lt;E fromElement&gt;</code></td>
<td class="org-left">返回一个新的集合，新集合包含原集合中 <code>fromElement</code> 对象之后的所有对象，包含 <code>fromElement</code> 对象。</td>
</tr>
</tbody>
</table>

<p>
*注：表面上看起来这些方法很多，其实很简单。因为 <code>TreeSet</code> 中的元素是 <span class="underline">有序的</span> ，所以增加了访问第一个、前一个、后一个、最后一个元素的方法，并提供了 3 个从 <code>TreeSet</code> 中截取子 <code>TreeSet</code> 的方法。
</p>

<p>
在使用自然排序时只能向 <code>TreeSet</code> 集合中添加相同数据类型的对象，否则会抛出 <code>ClassCastException</code> 异常。
</p>
</div>
</div>
</div>

<div id="outline-container-org14f4e61" class="outline-2">
<h2 id="org14f4e61">Map 集合</h2>
<div class="outline-text-2" id="text-org14f4e61">
<p>
<code>Map</code> 是一种键值对（ <code>key-value</code> ）集合，用于保存具有映射关系的数据。
</p>

<p>
<code>Map</code> 集合里保存着两组值，一组值用于保存 <code>Key</code> ，另一组值用于保存 <code>value</code> ， <b><code>Key</code> 和 <code>value</code> 都可以是任何引用类型的数据</b> 。其中， <code>key</code> 不允许重复， <code>value</code> 可以重复。
</p>

<p>
<code>Map</code> 中的 <code>key</code> 和 <code>value</code> 之间存在单向一对一关系，即通过指定的 <code>key</code> ，总能找到唯一的、确定的 <code>value</code> 。
</p>

<p>
<code>Map</code> 接口主要有两个实现类： <code>HashMap</code> 类和 <code>TreeMap</code> 类。其中， <code>HashMap</code> 类按哈希算法来存取键对象，而 <code>TreeMap</code> 类可以对键对象进行排序。
</p>

<table>
<caption class="t-above"><span class="table-number">Table 8:</span> Map 接口的常用方法</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法名称</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>void clear()</code></td>
<td class="org-left">删除该 <code>Map</code> 对象中的所有 <code>key-value</code> 对。</td>
</tr>

<tr>
<td class="org-left"><code>boolean containsKey(Object key)</code></td>
<td class="org-left">查询 <code>Map</code> 中是否包含指定的 <code>key</code> ，如果包含则返回 <code>true</code> 。</td>
</tr>

<tr>
<td class="org-left"><code>boolean containsValue(Object value)</code></td>
<td class="org-left">查询 <code>Map</code> 中是否包含一个或多个的 <code>value</code> ，如果包含则返回 <code>true</code> 。</td>
</tr>

<tr>
<td class="org-left"><code>V get(Object key)</code></td>
<td class="org-left">返回 <code>Map</code> 集合中指定键对象所对应的值， <code>V</code> 表示值的数据类型。</td>
</tr>

<tr>
<td class="org-left"><code>V put(K key, V value)</code></td>
<td class="org-left">向 <code>Map</code> 集合中添加键-值对，如果当前 <code>Map</code> 中已有一个与该 <code>key</code> 相等的 <code>key-value</code> 对，则新的 <code>key-value</code> 对会覆盖原来的 <code>key-value</code> 对。</td>
</tr>

<tr>
<td class="org-left"><code>void putAll(Map m)</code></td>
<td class="org-left">将指定 <code>Map</code> 中的 <code>key-value</code> 对复制到本 <code>Map</code> 中。</td>
</tr>

<tr>
<td class="org-left"><code>V remove(Object key)</code></td>
<td class="org-left">从 <code>Map</code> 集合中删除 <code>key</code> 对应的键-值对，返回 <code>key</code> 对应的 <code>value</code> ，如果该 <code>key</code> 不存在，则返回 <code>null</code> 。</td>
</tr>

<tr>
<td class="org-left"><code>boolean remove(Object key, Object value)</code></td>
<td class="org-left">（Java 8 新增）删除指定 <code>key、value</code> 所对应的 <code>key-value</code> 对。如果从该 <code>Map</code> 中成功地删除该 <code>key-value</code> 对，该方法返回 <code>true</code> ，否则返回 <code>false</code> 。</td>
</tr>

<tr>
<td class="org-left"><code>Set entrySet()</code></td>
<td class="org-left">返回 <code>Map</code> 集合中所有键-值对的 <code>Set</code> 集合，此 <code>Set</code> 集合中元素的数据类型为 <code>Map.Entry</code></td>
</tr>

<tr>
<td class="org-left"><code>Set keySet()</code></td>
<td class="org-left">返回 <code>Map</code> 集合中所有键对象的 <code>Set</code> 集合</td>
</tr>

<tr>
<td class="org-left"><code>boolean isEmpty()</code></td>
<td class="org-left">查询该 <code>Map</code> 是否为空（即不包含任何 <code>key-value</code> 对），如果为空则返回 <code>true</code> 。</td>
</tr>

<tr>
<td class="org-left"><code>int size()</code></td>
<td class="org-left">返回该 <code>Map</code> 里 <code>key-value</code> 对的个数</td>
</tr>

<tr>
<td class="org-left"><code>Collection values()</code></td>
<td class="org-left">返回该 <code>Map</code> 里所有 <code>value</code> 组成的 <code>Collection</code></td>
</tr>
</tbody>
</table>

<p>
<code>Map</code> 集合最典型的用法就是成对地添加、删除 <code>key-value</code> 对，接下来即可判断该 <code>Map</code> 中是否包含指定 <code>key</code> ，也可以通过 <code>Map</code> 提供的 <code>keySet()</code> 方法获取所有 <code>key</code> 组成的集合，进而遍历 <code>Map</code> 中所有的 <code>key-value</code> 对。
</p>

<p>
<b>*注： <code>TreeMap</code> 类的使用方法与 <code>HashMap</code> 类相同，唯一不同的是 <code>TreeMap</code> 类可以对键对象进行排序。</b>
</p>

<p>
<span class="underline">#. 遍历 Map 集合</span>
</p>

<p>
<code>Map</code> 集合的遍历与 <code>List</code> 和 <code>Set</code> 集合不同。 <code>Map</code> 有两组值，因此遍历时可以只遍历值的集合，也可以只遍历键的集合，也可以同时遍历。 <code>Map</code> 以及实现 <code>Map</code> 的接口类（如 <code>HashMap、TreeMap、LinkedHashMap、Hashtable</code> 等）都可以用以下几种方式遍历。
</p>

<p>
（1）在 <code>for</code> 循环中使用 <code>entries</code> 实现 <code>Map</code> 的遍历（最常见和最常用的）。
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">main</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">String</span><span style="color: #66D9EF;">[]</span> <span style="color: #FD971F;">args</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #66D9EF;">Map</span><span style="color: #66D9EF;">&lt;</span><span style="color: #66D9EF;">String</span>, <span style="color: #66D9EF;">String</span><span style="color: #66D9EF;">&gt;</span> <span style="color: #FD971F;">map</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">HashMap</span><span style="color: #66D9EF;">&lt;</span><span style="color: #66D9EF;">String</span>, <span style="color: #66D9EF;">String</span><span style="color: #66D9EF;">&gt;()</span>;
<span class="linenr"> 3: </span>    map.put<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">"Java Tutor"</span>, <span style="color: #E6DB74;">"tutor/java/"</span><span style="color: #66D9EF;">)</span>;
<span class="linenr"> 4: </span>    map.put<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">"C++ Tutor"</span>, <span style="color: #E6DB74;">"tutor/cpp/"</span><span style="color: #66D9EF;">)</span>;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>    <span style="color: #F92672;">for</span> <span style="color: #66D9EF;">(</span><span style="color: #AE81FF;">Map</span>.<span style="color: #66D9EF;">Entry</span><span style="color: #A6E22E;">&lt;</span><span style="color: #66D9EF;">String</span>, <span style="color: #66D9EF;">String</span><span style="color: #A6E22E;">&gt;</span> <span style="color: #A6E22E;">entry</span> : map.entrySet<span style="color: #A6E22E;">()</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 7: </span>        <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">mapKey</span> = entry.getKey<span style="color: #A6E22E;">()</span>;
<span class="linenr"> 8: </span>        <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">mapValue</span> = entry.getValue<span style="color: #A6E22E;">()</span>;
<span class="linenr"> 9: </span>        System.out.println<span style="color: #A6E22E;">(</span>mapKey + <span style="color: #E6DB74;">": "</span> + mapValue<span style="color: #A6E22E;">)</span>;
<span class="linenr">10: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">11: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
（2）使用 <code>for-each</code> 循环遍历 <code>key</code> 或者 <code>values</code> ，一般适用于只需要 <code>Map</code> 中的 <code>key</code> 或者 <code>value</code> 时使用，性能上 <code>entrySet</code> 较好。
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">main</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">String</span><span style="color: #66D9EF;">[]</span> <span style="color: #FD971F;">args</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #66D9EF;">Map</span><span style="color: #66D9EF;">&lt;</span><span style="color: #66D9EF;">String</span>, <span style="color: #66D9EF;">String</span><span style="color: #66D9EF;">&gt;</span> <span style="color: #FD971F;">map</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">HashMap</span><span style="color: #66D9EF;">&lt;</span><span style="color: #66D9EF;">String</span>, <span style="color: #66D9EF;">String</span><span style="color: #66D9EF;">&gt;()</span>;
<span class="linenr"> 3: </span>    map.put<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">"Java Tutor"</span>, <span style="color: #E6DB74;">"tutor/java/"</span><span style="color: #66D9EF;">)</span>;
<span class="linenr"> 4: </span>    map.put<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">"C++ Tutor"</span>, <span style="color: #E6DB74;">"tutor/cpp/"</span><span style="color: #66D9EF;">)</span>;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>    <span style="color: #F92672;">for</span> <span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">String</span> <span style="color: #A6E22E;">key</span> : map.keySet<span style="color: #A6E22E;">()</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 7: </span>        System.out.println<span style="color: #A6E22E;">(</span>key<span style="color: #A6E22E;">)</span>;
<span class="linenr"> 8: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    <span style="color: #F92672;">for</span> <span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">String</span> <span style="color: #A6E22E;">value</span> : map.values<span style="color: #A6E22E;">()</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">11: </span>        System.out.println<span style="color: #A6E22E;">(</span>value<span style="color: #A6E22E;">)</span>;
<span class="linenr">12: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">13: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
（3）使用迭代器（ <code>Iterator</code> ）遍历
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">main</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">String</span><span style="color: #66D9EF;">[]</span> <span style="color: #FD971F;">args</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #66D9EF;">Map</span><span style="color: #66D9EF;">&lt;</span><span style="color: #66D9EF;">String</span>, <span style="color: #66D9EF;">String</span><span style="color: #66D9EF;">&gt;</span> <span style="color: #FD971F;">map</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">HashMap</span><span style="color: #66D9EF;">&lt;</span><span style="color: #66D9EF;">String</span>, <span style="color: #66D9EF;">String</span><span style="color: #66D9EF;">&gt;()</span>;
<span class="linenr"> 3: </span>    map.put<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">"Java Tutor"</span>, <span style="color: #E6DB74;">"tutor/java/"</span><span style="color: #66D9EF;">)</span>;
<span class="linenr"> 4: </span>    map.put<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">"C++ Tutor"</span>, <span style="color: #E6DB74;">"tutor/cpp/"</span><span style="color: #66D9EF;">)</span>;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>    <span style="color: #66D9EF;">Iterator</span><span style="color: #66D9EF;">&lt;</span><span style="color: #66D9EF;">Entry</span><span style="color: #A6E22E;">&lt;</span><span style="color: #66D9EF;">String</span>, <span style="color: #66D9EF;">String</span><span style="color: #A6E22E;">&gt;</span><span style="color: #66D9EF;">&gt;</span> <span style="color: #FD971F;">entries</span> = map.entrySet<span style="color: #66D9EF;">()</span>.iterator<span style="color: #66D9EF;">()</span>;
<span class="linenr"> 7: </span>    <span style="color: #F92672;">while</span> <span style="color: #66D9EF;">(</span>entries.hasNext<span style="color: #A6E22E;">()</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 8: </span>        <span style="color: #66D9EF;">Entry</span><span style="color: #A6E22E;">&lt;</span><span style="color: #66D9EF;">String</span>, <span style="color: #66D9EF;">String</span><span style="color: #A6E22E;">&gt;</span> <span style="color: #FD971F;">entry</span> = entries.next<span style="color: #A6E22E;">()</span>;
<span class="linenr"> 9: </span>        <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">key</span> = entry.getKey<span style="color: #A6E22E;">()</span>;
<span class="linenr">10: </span>        <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">value</span> = entry.getValue<span style="color: #A6E22E;">()</span>;
<span class="linenr">11: </span>        System.out.println<span style="color: #A6E22E;">(</span>key + <span style="color: #E6DB74;">": "</span> + value<span style="color: #A6E22E;">)</span>;
<span class="linenr">12: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">13: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
（4）通过键值遍历，这种方式的效率比较低，因为本身从键值是耗时的操作。
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #F92672;">for</span> <span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">String</span> <span style="color: #A6E22E;">key</span> : map.keySet<span style="color: #66D9EF;">()</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span>
<span class="linenr">2: </span>    <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">value</span> = map.get<span style="color: #66D9EF;">(</span>key<span style="color: #66D9EF;">)</span>;
<span class="linenr">3: </span>    System.out.println<span style="color: #66D9EF;">(</span>key + <span style="color: #E6DB74;">": "</span> + value<span style="color: #66D9EF;">)</span>;
<span class="linenr">4: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org4cfe5ee" class="outline-2">
<h2 id="org4cfe5ee"><span class="todo TODO">TODO</span> Collections 类</h2>
</div>

<div id="outline-container-org5ce4b13" class="outline-2">
<h2 id="org5ce4b13">泛型</h2>
<div class="outline-text-2" id="text-org5ce4b13">
<p>
前面我们提到 Java 集合有个缺点，就是把一个对象“丢进”集合里之后，集合就会“忘记”这个对象的数据类型，当再次取出对象时，该对象的编译类型就变成了 <code>Object</code> 类型（其运行时类型没变）。
</p>

<p>
Java 集合之所以被设计成这样，是因为集合的设计者不知道我们用集合来保存什么类型的对象，所以他们把集合设计成能保存任何类型的对象，只需求具有很好的通用性。但这样做带来如下两个问题：
</p>

<p>
（1）集合对元素类型没有任何限制，这可能引发一些问题，例如，想创建一个只能保存 <code>Dog</code> 对象的集合，但程序也可以轻易地将 <code>Cat</code> 对象“丢”进去，所以可能引发异常。
</p>

<p>
（2）由于把对象“丢进”集合时，集合丢失了对象的状态信息，集合只知道它盛装的是 <code>Object</code> ，因此取出集合元素后通常还需要进行强制类型转换。这种强制类型转换既增加了编程的复杂度，也可能引发 <code>ClassCastException</code> 异常。
</p>

<p>
为了解决上述问题，从 Java 1.5 开始提供了泛型。
</p>

<p>
<b>泛型可以在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高了代码的重用率。</b>
</p>
</div>

<div id="outline-container-org9c583b1" class="outline-3">
<h3 id="org9c583b1">泛型集合</h3>
<div class="outline-text-3" id="text-org9c583b1">
<p>
<b>泛型，本质上是提供类型的“类型参数”，也就是参数化类型。</b>
</p>

<p>
我们可以为类、接口或方法指定一个类型参数，通过这个参数限制操作的数据类型，从而保证类型转换的绝对安全。
</p>

<p>
来看个例子，下面将结合泛型与集合编写一个案例实现图书信息输出：
</p>

<p>
（1）首先创建一个表示图书的实体类 <code>Book</code> ，其中包括图书信息的编号、名称和价格。代码如下：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">Book</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #F92672;">private</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">Id</span>;
<span class="linenr"> 3: </span>    <span style="color: #F92672;">private</span> <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">Name</span>;
<span class="linenr"> 4: </span>    <span style="color: #F92672;">private</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">Price</span>;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>    <span style="color: #F92672;">public</span> <span style="color: #A6E22E;">Book</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">id</span>, <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">name</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">price</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 7: </span>        <span style="color: #F92672;">this</span>.Id = id;
<span class="linenr"> 8: </span>        <span style="color: #F92672;">this</span>.Name = name;
<span class="linenr"> 9: </span>        <span style="color: #F92672;">this</span>.Price = price;
<span class="linenr">10: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">11: </span>
<span class="linenr">12: </span>    <span style="color: #F92672;">public</span> <span style="color: #66D9EF;">String</span> <span style="color: #A6E22E;">toString</span><span style="color: #66D9EF;">()</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">13: </span>        <span style="color: #F92672;">return</span> <span style="color: #F92672;">this</span>.Id + <span style="color: #E6DB74;">", "</span> + <span style="color: #F92672;">this</span>.Name + <span style="color: #E6DB74;">", "</span> + <span style="color: #F92672;">this</span>.Price;
<span class="linenr">14: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">15: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
（2）使用 Book 作为类型创建 Map 和 List 两个泛型集合，然后向集合中添加图书元素，最后输出集合中的内容，代码如下：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">Test</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">main</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">String</span><span style="color: #A6E22E;">[]</span> <span style="color: #FD971F;">args</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 3: </span>        <span style="color: #66D9EF;">Book</span> <span style="color: #FD971F;">book1</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">Book</span><span style="color: #A6E22E;">(</span>1, <span style="color: #E6DB74;">"BOOK1"</span>, 8<span style="color: #A6E22E;">)</span>;
<span class="linenr"> 4: </span>        <span style="color: #66D9EF;">Book</span> <span style="color: #FD971F;">book2</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">Book</span><span style="color: #A6E22E;">(</span>2, <span style="color: #E6DB74;">"BOOK2"</span>, 12<span style="color: #A6E22E;">)</span>;
<span class="linenr"> 5: </span>        <span style="color: #66D9EF;">Book</span> <span style="color: #FD971F;">book3</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">Book</span><span style="color: #A6E22E;">(</span>3, <span style="color: #E6DB74;">"BOOK3"</span>, 22<span style="color: #A6E22E;">)</span>;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#23450;&#20041;&#27867;&#22411; Map &#38598;&#21512;</span>
<span class="linenr"> 8: </span>        <span style="color: #66D9EF;">Map</span><span style="color: #A6E22E;">&lt;</span><span style="color: #66D9EF;">Integer</span>, <span style="color: #66D9EF;">Book</span><span style="color: #A6E22E;">&gt;</span> <span style="color: #FD971F;">books</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">HashMap</span><span style="color: #A6E22E;">&lt;</span><span style="color: #66D9EF;">Integer</span>, <span style="color: #66D9EF;">Book</span><span style="color: #A6E22E;">&gt;()</span>;
<span class="linenr"> 9: </span>        books.put<span style="color: #A6E22E;">(</span>1001, book1<span style="color: #A6E22E;">)</span>;
<span class="linenr">10: </span>        books.put<span style="color: #A6E22E;">(</span>1002, book2<span style="color: #A6E22E;">)</span>;
<span class="linenr">11: </span>        books.put<span style="color: #A6E22E;">(</span>1003, book3<span style="color: #A6E22E;">)</span>;
<span class="linenr">12: </span>        System.out.println<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"&#27867;&#22411; Map &#23384;&#20648;&#30340;&#22270;&#20070;&#20449;&#24687;&#22914;&#19979;&#65306;"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">13: </span>        <span style="color: #F92672;">for</span> <span style="color: #A6E22E;">(</span><span style="color: #66D9EF;">Integer</span> <span style="color: #A6E22E;">id</span> : books.keySet<span style="color: #E6DB74;">()</span><span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span>
<span class="linenr">14: </span>            System.out.println<span style="color: #E6DB74;">(</span>id + <span style="color: #E6DB74;">"--"</span><span style="color: #E6DB74;">)</span>;
<span class="linenr">15: </span>            System.out.println<span style="color: #E6DB74;">(</span>books.get<span style="color: #FD971F;">(</span>id<span style="color: #FD971F;">)</span><span style="color: #E6DB74;">)</span>; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#19981;&#38656;&#35201;&#31867;&#22411;&#36716;&#25442;</span>
<span class="linenr">16: </span>        <span style="color: #A6E22E;">}</span>
<span class="linenr">17: </span>
<span class="linenr">18: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#23450;&#20041;&#27867;&#22411;&#30340; List &#38598;&#21512;</span>
<span class="linenr">19: </span>        <span style="color: #66D9EF;">List</span><span style="color: #A6E22E;">&lt;</span><span style="color: #66D9EF;">Book</span><span style="color: #A6E22E;">&gt;</span> <span style="color: #FD971F;">bookList</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">ArrayList</span><span style="color: #A6E22E;">&lt;</span><span style="color: #66D9EF;">Book</span><span style="color: #A6E22E;">&gt;()</span>;
<span class="linenr">20: </span>        bookList.add<span style="color: #A6E22E;">(</span>book1<span style="color: #A6E22E;">)</span>;
<span class="linenr">21: </span>        bookList.add<span style="color: #A6E22E;">(</span>book2<span style="color: #A6E22E;">)</span>;
<span class="linenr">22: </span>        bookList.add<span style="color: #A6E22E;">(</span>book3<span style="color: #A6E22E;">)</span>;
<span class="linenr">23: </span>        System.out.println<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"&#27867;&#22411; List &#23384;&#20648;&#30340;&#22270;&#20070;&#20449;&#24687;&#22914;&#19979;&#65306;"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">24: </span>        <span style="color: #F92672;">for</span> <span style="color: #A6E22E;">(</span><span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">i</span> = 0; i &lt; bookList.<span style="color: #66D9EF;">size</span><span style="color: #E6DB74;">()</span>; i++<span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span>
<span class="linenr">25: </span>            System.out.println<span style="color: #E6DB74;">(</span>bookList.get<span style="color: #FD971F;">(</span>i<span style="color: #FD971F;">)</span><span style="color: #E6DB74;">)</span>; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#19981;&#38656;&#35201;&#31867;&#22411;&#36716;&#25442;</span>
<span class="linenr">26: </span>        <span style="color: #A6E22E;">}</span>
<span class="linenr">27: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">28: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
在该示例中，第 8 行代码创建了一个键类型为 <code>Integer</code> 、值类型为 <code>Book</code> 的泛型集合，即该 <code>Map</code> 集合中存放的键必须是 <code>Integer</code> 类型、值必须为 <code>Book</code> 类型，否则编译出错。在获取 <code>Map</code> 集合中的元素时，不需要将 <code>books.get(id);</code> 获取的值强制转换为 <code>Book</code> 类型，程序会隐式转换。
</p>

<p>
第 19 行代码在创建 <code>List</code> 集合时，同样使用了泛型，因此在获取集合中的元素时也不需要将 <code>bookList.get(i)</code> 代码强制转换为 <code>Book</code> 类型，程序会隐式转换。
</p>
</div>
</div>

<div id="outline-container-orga8101d4" class="outline-3">
<h3 id="orga8101d4">泛型类</h3>
<div class="outline-text-3" id="text-orga8101d4">
<p>
除了可以定义泛型集合之外，还可以直接限定泛型类的类型参数，语法格式如下：
</p>

<pre class="example">
public class class_name&lt;data_type1, data_type2, ...&gt; {}
</pre>

<p>
其中， <code>class_name</code> 表示类的名称， <code>data_type1</code> 等表示类型参数。Java 泛型支持声明一个以上的类型参数，只需要将类型用逗号隔开即可。
</p>

<p>
<b>泛型类一般用于类中的属性类型不确定的情况下。</b> 在声明属性时，使用下面的语句：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #F92672;">private</span> <span style="color: #66D9EF;">data_type1</span> <span style="color: #FD971F;">property_name1</span>;
<span class="linenr">2: </span><span style="color: #F92672;">private</span> <span style="color: #66D9EF;">data_type2</span> <span style="color: #FD971F;">property_name2</span>;
</pre>
</div>

<p>
该语句中的 <code>data_type1</code> 与类声明中的 <code>data_type1</code> 表示的是同一种数据类型。
</p>

<p>
<b>在实例化泛型类时，需要指明泛型类中的类型参数，并赋予泛型类属性相应类型的值。</b>
</p>

<p>
下面我们来看一个例子，创建了一个表示学生的泛型类，该类中包括 3 个属性，分别是姓名、年龄和性别。
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">Stu</span><span style="color: #AE81FF;">&lt;</span><span style="color: #66D9EF;">N</span>, <span style="color: #66D9EF;">A</span>, <span style="color: #66D9EF;">S</span><span style="color: #AE81FF;">&gt;</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #F92672;">private</span> <span style="color: #66D9EF;">N</span> <span style="color: #FD971F;">name</span>;
<span class="linenr"> 3: </span>    <span style="color: #F92672;">private</span> <span style="color: #66D9EF;">A</span> <span style="color: #FD971F;">age</span>;
<span class="linenr"> 4: </span>    <span style="color: #F92672;">private</span> <span style="color: #66D9EF;">S</span> <span style="color: #FD971F;">sex</span>;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">&#21019;&#24314;&#31867;&#30340;&#26500;&#36896;&#20989;&#25968;</span>
<span class="linenr"> 7: </span>    <span style="color: #F92672;">public</span> <span style="color: #A6E22E;">Stu</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">N</span> <span style="color: #FD971F;">name</span>, <span style="color: #66D9EF;">A</span> <span style="color: #FD971F;">age</span>, <span style="color: #66D9EF;">S</span> <span style="color: #FD971F;">sex</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 8: </span>        <span style="color: #F92672;">this</span>.name = name;
<span class="linenr"> 9: </span>        <span style="color: #F92672;">this</span>.age = age;
<span class="linenr">10: </span>        <span style="color: #F92672;">this</span>.sex = sex;
<span class="linenr">11: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">12: </span>
<span class="linenr">13: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">&#19979;&#38754;&#26159;&#19978;&#38754; 3 &#20010;&#23646;&#24615;&#30340; setter/getter &#26041;&#27861;</span>
<span class="linenr">14: </span>    <span style="color: #F92672;">public</span> <span style="color: #66D9EF;">N</span> <span style="color: #A6E22E;">getName</span><span style="color: #66D9EF;">()</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">15: </span>        <span style="color: #F92672;">return</span> name;
<span class="linenr">16: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">17: </span>    <span style="color: #F92672;">public</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">setName</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">N</span> <span style="color: #FD971F;">name</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">18: </span>        <span style="color: #F92672;">this</span>.name = name;
<span class="linenr">19: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">20: </span>
<span class="linenr">21: </span>    <span style="color: #F92672;">public</span> <span style="color: #66D9EF;">A</span> <span style="color: #A6E22E;">getAge</span><span style="color: #66D9EF;">()</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">22: </span>        <span style="color: #F92672;">return</span> age;
<span class="linenr">23: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">24: </span>    <span style="color: #F92672;">public</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">setAge</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">A</span> <span style="color: #FD971F;">age</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">25: </span>        <span style="color: #F92672;">this</span>.age = age;
<span class="linenr">26: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">27: </span>
<span class="linenr">28: </span>    <span style="color: #F92672;">public</span> <span style="color: #66D9EF;">S</span> <span style="color: #A6E22E;">getSex</span><span style="color: #66D9EF;">()</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">29: </span>        <span style="color: #F92672;">return</span> sex;
<span class="linenr">30: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">31: </span>    <span style="color: #F92672;">public</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">setSex</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">S</span> <span style="color: #FD971F;">sex</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">32: </span>        <span style="color: #F92672;">this</span>.sex = sex;
<span class="linenr">33: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">34: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
接着创建测试类，在测试类中调用 Stu 类的构造方法实例化 Stu 对象，并给该类中的 3 个属性赋初始值，最终需要输出学生信息，代码如下：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">Test</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">main</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">String</span><span style="color: #A6E22E;">[]</span> <span style="color: #FD971F;">args</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 3: </span>        <span style="color: #66D9EF;">Stu</span><span style="color: #A6E22E;">&lt;</span><span style="color: #66D9EF;">String</span>, <span style="color: #66D9EF;">Integer</span>, <span style="color: #66D9EF;">Character</span><span style="color: #A6E22E;">&gt;</span> <span style="color: #FD971F;">stu</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">Stu</span><span style="color: #A6E22E;">&lt;</span><span style="color: #66D9EF;">String</span>, <span style="color: #66D9EF;">Integer</span>, <span style="color: #66D9EF;">Character</span><span style="color: #A6E22E;">&gt;(</span><span style="color: #E6DB74;">"Amy"</span>, 32, <span style="color: #E6DB74;">"Female"</span> <span style="color: #A6E22E;">)</span>;
<span class="linenr"> 4: </span>        <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">name</span> = stu.getName<span style="color: #A6E22E;">()</span>;
<span class="linenr"> 5: </span>        <span style="color: #66D9EF;">Integer</span> <span style="color: #FD971F;">age</span> = stu.getAge<span style="color: #A6E22E;">()</span>;
<span class="linenr"> 6: </span>        <span style="color: #66D9EF;">Character</span> <span style="color: #FD971F;">sex</span> = stu.getSex<span style="color: #A6E22E;">()</span>;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>        System.out.println<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"NAME: "</span> + name + <span style="color: #E6DB74;">", AGE: "</span> + age + <span style="color: #E6DB74;">", SEX: "</span> + sex<span style="color: #A6E22E;">)</span>;
<span class="linenr"> 9: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; NAME: Amy, AGE: 32, SEX: Female</span>
<span class="linenr">10: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">11: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
在程序的 Stu 类中，定义了 3 个类型参数，分别使用 <code>N、A</code> 和 <code>S</code> 来代替，同时实现了这 3 个属性的 <code>setter/getter</code> 方法。在主类中，调用 Stu 类的构造函数创建了 Stu 类的对象，同时指定 3 个类型参数，分别为 <code>String、Integer</code> 和 <code>Character</code> 。在获取学生姓名、年龄和性别时，不需要类型转换，程序隐式地将 Object 类型的数据转换为相应的数据类型。
</p>
</div>
</div>

<div id="outline-container-org89c270a" class="outline-3">
<h3 id="org89c270a">泛型方法</h3>
<div class="outline-text-3" id="text-org89c270a">
<p>
泛型同样可以应用在类中包含参数化的方法，而方法所在的类可以是泛型类，也可以不是泛型类。
</p>

<p>
泛型方法使得该方法能够独立于类而产生变化，如果使用泛型方法可以取代类泛型化，那么就应该只使用泛型方法。另外，对一个 <code>static</code> 的方法而言，无法访问泛型类的类型参数。因此，如果 <code>static</code> 方法需要使用泛型能力，就必须使其成为泛型方法。
</p>

<p>
定义泛型方法的语法格式如下：
</p>

<pre class="example">
[访问权限修饰符] [static] [final] &lt;类型参数列表&gt; 返回值类型方法名([形式参数列表])
</pre>

<p>
如：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">List</span><span style="color: #AE81FF;">&lt;</span><span style="color: #66D9EF;">T</span><span style="color: #AE81FF;">&gt;</span> <span style="color: #A6E22E;">find</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">Class</span><span style="color: #66D9EF;">&lt;</span><span style="color: #66D9EF;">T</span><span style="color: #66D9EF;">&gt;</span><span style="color: #F92672;">class</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">userId</span><span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{}</span>
</pre>
</div>

<p>
一般来说编写 Java 泛型方法，其返回值类型至少有一个参数类型应该是泛型，而且类型应该是一致的，如果只有返回值类型或参数类型之一使用了泛型，那么这个泛型方法的使用就被限制了。
</p>

<p>
下面来定义一个泛型方法，具体介绍泛型方法的创建和使用。
</p>

<p>
定义泛型方法，参数类型使用 <code>T</code> 来代替，在方法的主体中打印出图书信息，代码实现如下：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">Test</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">&lt;</span><span style="color: #66D9EF;">T</span><span style="color: #66D9EF;">&gt;</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">List</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">T</span> <span style="color: #FD971F;">book</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span> <span style="color: #75715E;">// </span><span style="color: #75715E;">&#23450;&#20041;&#27867;&#22411;&#26041;&#27861;</span>
<span class="linenr"> 3: </span>        <span style="color: #F92672;">if</span> <span style="color: #A6E22E;">(</span>book != <span style="color: #AE81FF;">null</span><span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span>
<span class="linenr"> 4: </span>            System.out.println<span style="color: #E6DB74;">(</span>book<span style="color: #E6DB74;">)</span>;
<span class="linenr"> 5: </span>        <span style="color: #A6E22E;">}</span>
<span class="linenr"> 6: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>    <span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">main</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">String</span><span style="color: #A6E22E;">[]</span> <span style="color: #FD971F;">args</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 9: </span>        <span style="color: #66D9EF;">Book</span> <span style="color: #FD971F;">stu</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">Book</span><span style="color: #A6E22E;">(</span>1, <span style="color: #E6DB74;">"Learn Coding"</span>, 28<span style="color: #A6E22E;">)</span>;
<span class="linenr">10: </span>        <span style="color: #66D9EF;">List</span><span style="color: #A6E22E;">(</span><span style="color: #66D9EF;">stu</span><span style="color: #A6E22E;">)</span>;                       <span style="color: #75715E;">// </span><span style="color: #75715E;">&#35843;&#29992;&#27867;&#22411;&#26041;&#27861;</span>
<span class="linenr">11: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#8594; 1, Learn Coding, 28</span>
<span class="linenr">12: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">13: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
该程序中的 Book 类为前面示例中使用到的 Book 类。在该程序中定义了一个名称为 <code>List</code> 的方法，该方法的返回值类型为 <code>void</code> ，类型参数使用 <code>T</code> 来代替。在调用该泛型方法时，将一个 Book 对象作为参数传递到该方法中，相当于指明了该泛型方法的参数类型为 Book 。
</p>
</div>
</div>

<div id="outline-container-orgf317e0d" class="outline-3">
<h3 id="orgf317e0d"><span class="todo TODO">TODO</span> 泛型的高级用法</h3>
</div>
</div>

<div id="outline-container-org4f15560" class="outline-2">
<h2 id="org4f15560">图书信息查询</h2>
<div class="outline-text-2" id="text-org4f15560">
<p>
在实际开发中，泛型集合是较常用的，一般定义集合都会使用泛型来定义。
</p>

<p>
下面我们使用泛型集合来模拟实现某图书管理系统的查询功能 &#x2013; 在图书管理系统中为了方便管理图书，将图书划分为几个类别，每个类别对应多本图书，这就具备了一对多的关系映射。
</p>

<p>
在这种情况下就可以使用 Map 映射来存储类别和图书信息，其键为 <code>Category</code> （类别）类型，值为 <code>List&lt;Book&gt;</code> 类型（Book 类为图书类），然后使用嵌套循环遍历输出每个类别所对应的多个图书信息。具体的实现步骤如下：
</p>

<p>
（1）创建表示图书类的 Category 类，在该类中有两个属性： <code>id</code> 和 <code>name</code> ，分别表示编号和类别名称，并实现了它们的 <code>setter/getter</code> ，具体内容如下：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">Category</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #F92672;">private</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">id</span>;             <span style="color: #75715E;">// </span><span style="color: #75715E;">&#31867;&#21035;&#32534;&#21495;</span>
<span class="linenr"> 3: </span>    <span style="color: #F92672;">private</span> <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">name</span>;        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#31867;&#21035;&#21517;&#31216;</span>
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>    <span style="color: #F92672;">public</span> <span style="color: #A6E22E;">Category</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">id</span>, <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">name</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 6: </span>        <span style="color: #F92672;">this</span>.id = id;
<span class="linenr"> 7: </span>        <span style="color: #F92672;">this</span>.name = name;
<span class="linenr"> 8: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    <span style="color: #F92672;">public</span> <span style="color: #66D9EF;">String</span> <span style="color: #A6E22E;">toString</span><span style="color: #66D9EF;">()</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">11: </span>        <span style="color: #F92672;">return</span> <span style="color: #E6DB74;">"&#25152;&#23646;&#20998;&#31867;&#65306;"</span> + <span style="color: #F92672;">this</span>.name;
<span class="linenr">12: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">13: </span>
<span class="linenr">14: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">getter/setter</span>
<span class="linenr">15: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">...</span>
<span class="linenr">16: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
（2）创建表示图书明细信息的 BookInfo 类，在该类中包含 5 个属性： <code>id、name、price、author</code> 和 <code>startTime</code> ，分另表示图书编号、名称、价格、作者和出版时间，同样实现的 <code>getter/setter</code> ，具体内容如下：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">BookInfo</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #F92672;">private</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">id</span>;             <span style="color: #75715E;">// </span><span style="color: #75715E;">&#32534;&#21495;</span>
<span class="linenr"> 3: </span>    <span style="color: #F92672;">private</span> <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">name</span>;        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#21517;&#31216;</span>
<span class="linenr"> 4: </span>    <span style="color: #F92672;">private</span> <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">price</span>;          <span style="color: #75715E;">// </span><span style="color: #75715E;">&#20215;&#26684;</span>
<span class="linenr"> 5: </span>    <span style="color: #F92672;">private</span> <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">author</span>;      <span style="color: #75715E;">// </span><span style="color: #75715E;">&#20316;&#32773;</span>
<span class="linenr"> 6: </span>    <span style="color: #F92672;">private</span> <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">startTime</span>;   <span style="color: #75715E;">// </span><span style="color: #75715E;">&#20986;&#29256;&#26102;&#38388;</span>
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>    <span style="color: #F92672;">public</span> <span style="color: #A6E22E;">BookInfo</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">id</span>, <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">name</span>, <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">price</span>, <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">author</span>, <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">startTime</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 9: </span>        <span style="color: #F92672;">this</span>.id = id;
<span class="linenr">10: </span>        <span style="color: #F92672;">this</span>.name = name;
<span class="linenr">11: </span>        <span style="color: #F92672;">this</span>.price = price;
<span class="linenr">12: </span>        <span style="color: #F92672;">this</span>.author = author;
<span class="linenr">13: </span>        <span style="color: #F92672;">this</span>.startTime = startTime;
<span class="linenr">14: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">15: </span>
<span class="linenr">16: </span>    <span style="color: #F92672;">public</span> <span style="color: #66D9EF;">String</span> <span style="color: #A6E22E;">toString</span><span style="color: #66D9EF;">()</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">17: </span>        <span style="color: #F92672;">return</span> <span style="color: #F92672;">this</span>.id + <span style="color: #E6DB74;">"\t\t"</span> + <span style="color: #F92672;">this</span>.name + <span style="color: #E6DB74;">"\t\t"</span> + <span style="color: #F92672;">this</span>.price + <span style="color: #E6DB74;">"\t\t"</span> + <span style="color: #F92672;">this</span>.author + <span style="color: #E6DB74;">"\t\t"</span> + <span style="color: #F92672;">this</span>.startTime;
<span class="linenr">18: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">19: </span>
<span class="linenr">20: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">&#19978;&#38754; 5 &#20010;&#23646;&#24615;&#30340; setter/getter</span>
<span class="linenr">21: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">...</span>
<span class="linenr">22: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
（3）创建 CategoryDao 类，在该类中定义了一个泛型的 Map 映射，其键为 Category 类型的对象，值为 <code>List&lt;BookInfo&gt;</code> 类型的对象，并定义 <code>printCategoryInfo()</code> 方法，用于打印类别和图书明细，具体代码如下：
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2020-09-29 Tue 19:05</p>
<p class="author">Author: Jack Liu</p>
<p class="date">Created: 2020-09-30 Wed 19:06</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
